{"pages":[{"title":"git","url":"/518e617c/","text":"引导在开发过程中，我们最常用的团队协同工具就是git，因此git常用操作必须要熟练掌握 多个git仓库推送：在公司开发或者个人开发一个模块，如果需要同步到个人或者公司的git仓库，这时候就显得尤其重要12345git remote set-url --add origin git@gitee.com:teamemory/myH5.git //给origin添加一个远程push地址，这样一次push就能同时push到两个地址上面git remote -v //查看是否多了一条push地址（这个可不执行）git push origin master -f // 推送到仓库git remote set-url --delete origin git@gitee.com:teamemory/myH5.git // 删除方法","tags":"git tools"},{"title":"rn-base","url":"/140ab620/","text":"前言大型RN项目中离不开拆包优化，通常拆包将bundle拆分成base和module包，base包中主要是将通用的第三方库及通用组件编译成一个独立的包供RN Context初始化时做全局加载，在页面加载时只需要加载并执行对应的module包即可。 环境依赖 npm git vv-rn base包开发方式 clone 项目到本地 123git clone https://g.gitvv.com/frontend/vv-rn.git# orgit clone ssh://git@git.gitvv.com:38022/frontend/vv-rn.git 如无项目权限，请联系相关负责人授予项目权限 前端项目初始化 123npm config set registry http://npm.gitvv.com/ # 设置镜像源npm login # 登录npm install # 安装依赖 修改相关代码代码可以直接修改，不需要修改配置即可发布生效 添加组件及工具类等公共文件 组件在components目录中添加，并需要在components/index.ts中export导出 工具类同样，在utils中添加，并需要在utils/index.ts中export导出 其他目录可自行添加，只要确保在src/index.tsx中export列表里包含添加的内容即可 添加外部依赖模块 package.json 中添加需要的模块并使用npm install或yarn install 安装，package.json详解见文章package.json 在src/index.tsx中import引入需要打到base 中的模块 如何将node_modules中模块打进module包 在业务项目根目录创建bundle.json文件，具体格式如下1234&#123; \"^__prelude__$\": false, \"/node_modules/\": false&#125; false：表示不编译进module包true：表示编译进module包注意：编译进modules包中的模块需要确定base包中不存在 编译配置 /build/metro.base.config.js业务项目编译base包的通用配置，一般不需要进行修改或者外部重新定义，因为里面集成了svg模块代码，需要了解相关配置才可外部重新定义 /build/metro.bundle.config.js业务项目编译module包的通用配置，一般不需要进行修改或者外部重新定义，因为里面集成了svg模块代码，需要了解相关配置才可外部重新定义，并根据编译时间生成module名，确保不同页面使用同一个文件，会将改文件编译成两个不同的模块进行引用，防止页面冲突 发布 做完以上工作后，可以进行vv-rn的发布，发布前首先需要修改package.json中的version版本号，否则会发布失败 修改完版本号后，使用下面命令进行发布1npm run pub pub命令对应文件在/publish.js中，如需了解，可以阅读。","tags":"随笔"},{"title":"node/index","url":"/92faf83c/","text":"#!/usr/bin/env node：从系统PATH中查找Node，解决不同用户Node安装问题 在开发npm包使用bin时，该行代码必须放在bin文件头部，否则，安装包后生成的.bin中可执行文件会报错 require的方法 require.resolve","tags":""},{"title":"Active IDEAL","url":"/396e831/","text":"前言JetBrains 系列软件在开发圈中越来越普及，相对来说在实用性方面是最受开发人员环境的，虽然在某种程度上被VSCode反超，然而VSCode是一款免费工具，而IDEAL是一款收费工具，目前仅支持教育免费，通常我们并不会去购买其激活码，因为太过昂贵，最多会在淘宝上购买第三方激活码，更多的是在放上搜索可用的激活码，但是对于最新版来说网上的激活码都已经失效，生成激活码的网站也已经关闭了生成功能，本文介绍目前可用且生成属于自己的activation code的方法。 使用方式 code 生成 代理包下载： 百度网盘下载 提取码：mmk6 OneDrive 下载成功后启动需要激活的软件，选择试用进入软件主界面。 点击Help-&gt;Edit Custom VM Options，编辑软件配置文件，添加-javaagent:E:\\webStorm\\jetbrains-agent.jar,具体地址为你解压文件地址。 点击Help-&gt;Register输入第一步中生成的activation code激活即可 其他详细使用步骤可以参考下载包中pdf文档 本文作者： Neo Peng 本文链接： https://zhile.io/2018/08/25/jetbrains-license-server-crack.html 版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！","tags":"tools ideal activation"},{"title":"Fetch","url":"/43284c47/","text":"前言前端开发中经常涉及到接口请求，而在h5中常用的接口请求框架有fetch、axios、umi-request，fetch功能比较简单，能够满足正常的api调用需要，axios和umi-request功能比较丰富，支持取消及拦截器操作。本文主要介绍fetch的功能扩展。 fetch 请求取消早期，fetch没有提供cancel操作是受到Promise的影响，计划中Promise是会提供cancel方法，fetch是打算使用Promise的cancel逻辑，但是Promise一直没有提供，因此造成fetch在使用方面不如axios和umi-request，但最近，fetch支持了cancel功能。其依赖于AbortController，低版本浏览器不支持AbortController的需要使用polyfill。具体demo如下： 12345678910111213141516171819202122232425262728293031323334353637const Ajax = (input: RequestInfo, init?: IIRequestInit):IFetchPromise&lt;any&gt;=&gt;&#123; const &#123;timeout,signal&#125; = init||&#123;&#125;; let _fetch:IFetchPromise&lt;any&gt;; const controller = new AbortController(); const _signal = controller.signal; const __fetch = fetch(input,&#123;...init,signal:_signal&#125;).then(response=&gt;&#123; return response.json() &#125;).then((json=&#123;&#125;)=&gt;&#123; const &#123;code,msg&#125; = json; if(code===0)&#123; return json; &#125; throw json; &#125;); signal?.addEventListener('abort', ()=&gt;&#123; controller.abort(); &#125;); if(timeout === void 0)&#123; // @ts-ignore _fetch=__fetch &#125;else&#123; // @ts-ignore _fetch =Promise.race([ __fetch, new Promise(function (_, reject) &#123; setTimeout(function () &#123; reject(new TypeError(`Network request failed,timeout of $&#123;timeout&#125; ms exceeded.`)); controller.abort(); &#125;, timeout); &#125;) ]); &#125; _fetch.cancel=()=&gt;&#123; controller.abort(); &#125;; return _fetch;&#125;; fetch 超时fetch超时一直以来也没有提供参数设置，可以参照取消请求的方式实现超时功能，当超时时取消请求并抛出超时异常 RN中优化RN中需要给每个Page组件提供一个fetch实例，当页面卸载时，调用该实例的cancel回收所有未完成的请求任务，释放资源","tags":"h5 ajax"},{"title":"svg","url":"/3452590/","text":"前言react-native中图片适配一直来说是个比较麻烦的问题，需要使用不同分辨率的图片，相对来说比较麻烦，对比与web端矢量图的应用，react-native中对于适量图svg的需求也越来越广泛。 前提react-native有一个svg的插件react-native-svg，该插件可以使用本地svg，但是旧版本在android生成release包时图片会不显示，因此svg的使用不尽人意，网上提供的方式是将svg通过脚本生成一个js文件存放svg中的xml，在配合SvgXml组件使用，该方法可行，但是每次添加图片时都需要执行脚本。 方案：react-native-svg 新版本发布后，支持配合metro或者babel直接使用svg图片的方案，其最终编译时也是将svg图片转换成xml字符串。具体参考插件","tags":"react-native"},{"title":"Call setState when unMounted","url":"/9bcaf31a/","text":"前言React开发过程中经常涉及到异步修改状态的问题，然而开发过程中会发现，某些操作会导致控制台提示当前组件已经卸载，不应该继续调用setState修改其状态，本文关于该问题点进行讨论。 官方官方讨论 React中每个组件提供了isMounted()方法去判断该组件是否被渲染，因此第一种方案可以为 123if (this.isMounted()) &#123; // This is bad. this.setState(&#123;...&#125;);&#125; 但是这种写法会使项目代码变得非常冗余且违背了警告的目的，官方也不建议使用 _isMounted变量控制在componentDidMount中将isMounted设为true，在componentWillUnmount中将其设置为false，调用setState时通过该变量进行判断，自己跟踪装载状态是为了兼容后续react升级，即使isMounted不可用也不会受到影响 将Api调用封装成可以cancel的对象在componentWillUnmount中将接口调用cancel掉，但是官方的cancel只是简单的cancel，并不能直接cancel接口调用，仍然会消耗流量 方法推荐 重写Component基类，改写setState方法 123456789101112// 仅供简单参考，具体使用根据个人框架理解去封装class BaseComponent extends React.Component&#123; constructor()&#123; super(); const setState = this.setState; this.setState=(data)=&gt;&#123; if(this.isMounted())&#123; setState(data); &#125; &#125; &#125;&#125; 重写Component基类，重置setState方法 123456// 仅供简单参考，具体使用根据个人框架理解去封装class BaseComponent extends React.Component&#123; componentWillUnmount()&#123; this.setState=()=&gt;&#123;&#125;; &#125;&#125; Cancel接口 1234567891011// 仅供简单参考，具体使用根据个人框架理解去封装class BaseComponent extends React.Component&#123; constructor()&#123; super(); this.fetch=new Fetch(); &#125; // this.fetch.post() componentWillUnmount()&#123; this.fetch.cancel();// cancel掉当前所有请求 &#125;&#125;","tags":"-react"},{"title":"optional-chaining","url":"/c97a3f02/","text":"前言","tags":"typescript babel optional-chaining"},{"title":"webpack","url":"/b9f20a20/","text":"前言前端开发中工程化越来越重要，而工程化工具中webpack的地位尤其重要，本文主要介绍webpack@4+的相关配置。 配置 mode:”production” | “development” | “none”设置webpack运行模式，不同的模式对应不同的默认配置值，例如optimization配置在production和development模式下默认值就有较大差别。同时模式的配置会使得webpack在编译时设置process.env.NODE_ENV的值，它不是Node中的环境变量，仅是webpack.DefinePlugin中定义的全局变量，因此在node进程中是无法获取到该值的，它仅对编译过程有效。 entry:string | object | array配置webpack入口文件，支持单页面和多页面方式制定入口文件，单页面使用string和array方式，多页面使用object方式。 插件 UglifyJsPlugin compress：转换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109export interface CompressOptions &#123; /** Replace `arguments[index]` with function parameter name whenever possible. */ arguments?: boolean; /** Various optimizations for boolean context, for example `!!a ? b : c → a ? b : c` */ booleans?: boolean; /** Collapse single-use non-constant variables, side effects permitting. */ collapse_vars?: boolean; /** Apply certain optimizations to binary nodes, e.g. `!(a &lt;= b) → a &gt; b,` attempts to negate binary nodes, e.g. `a = !b &amp;&amp; !c &amp;&amp; !d &amp;&amp; !e → a=!(b||c||d||e)` etc */ comparisons?: boolean; /** Apply optimizations for `if-s` and conditional expressions. */ conditionals?: boolean; /** Remove unreachable code */ dead_code?: boolean; /** * Pass `true` to discard calls to console.* functions. * If you wish to drop a specific function call such as `console.info` and/or retain side effects from function * arguments after dropping the function call then use `pure_funcs` instead. */ drop_console?: boolean; /** Remove `debugger;` statements */ drop_debugger?: boolean; /** Attempt to evaluate constant expressions */ evaluate?: boolean; /** Pass `true` to preserve completion values from terminal statements without `return`, e.g. in bookmarklets. */ expression?: boolean; global_defs?: object; /** hoist function declarations */ hoist_funs?: boolean; /** * Hoist properties from constant object and array literals into regular variables subject to a set of constraints. * For example: `var o=&#123;p:1, q:2&#125;; f(o.p, o.q);` is converted to `f(1, 2);`. Note: `hoist_props` works best with mangle enabled, * the compress option passes set to 2 or higher, and the compress option toplevel enabled. */ hoist_props?: boolean; /** Hoist var declarations (this is `false` by default because it seems to increase the size of the output in general) */ hoist_vars?: boolean; /** Optimizations for if/return and if/continue */ if_return?: boolean; /** * Inline calls to function with simple/return statement * - false -- same as `Disabled` * - `Disabled` -- disabled inlining * - `SimpleFunctions` -- inline simple functions * - `WithArguments` -- inline functions with arguments * - `WithArgumentsAndVariables` -- inline functions with arguments and variables * - true -- same as `WithArgumentsAndVariables` */ inline?: boolean | InlineFunctions; /** join consecutive `var` statements */ join_vars?: boolean; /** Prevents the compressor from discarding unused function arguments. You need this for code which relies on `Function.length` */ keep_fargs?: boolean; /** Pass true to prevent the compressor from discarding function names. Useful for code relying on `Function.prototype.name`. */ keep_fnames?: boolean; /** Pass true to prevent Infinity from being compressed into `1/0`, which may cause performance issues on `Chrome` */ keep_infinity?: boolean; /** Optimizations for `do`, `while` and `for` loops when we can statically determine the condition. */ loops?: boolean; /** negate `Immediately-Called Function Expressions` where the return value is discarded, to avoid the parens that the code generator would insert. */ negate_iife?: boolean; /** The maximum number of times to run compress. In some cases more than one pass leads to further compressed code. Keep in mind more passes will take more time. */ passes?: number; /** Rewrite property access using the dot notation, for example `foo[\"bar\"]` to `foo.bar` */ properties?: boolean; /** * An array of names and UglifyJS will assume that those functions do not produce side effects. * DANGER: will not check if the name is redefined in scope. * An example case here, for instance `var q = Math.floor(a/b)`. * If variable q is not used elsewhere, UglifyJS will drop it, but will still keep the `Math.floor(a/b)`, * not knowing what it does. You can pass `pure_funcs: [ 'Math.floor' ]` to let it know that this function * won't produce any side effect, in which case the whole statement would get discarded. The current * implementation adds some overhead (compression will be slower). */ pure_funcs?: string[]; pure_getters?: boolean | 'strict'; /** * Allows single-use functions to be inlined as function expressions when permissible allowing further optimization. * Enabled by default. Option depends on reduce_vars being enabled. Some code runs faster in the Chrome V8 engine if * this option is disabled. Does not negatively impact other major browsers. */ reduce_funcs?: boolean; /** Improve optimization on variables assigned with and used as constant values. */ reduce_vars?: boolean; sequences?: boolean; /** Pass false to disable potentially dropping functions marked as \"pure\". */ side_effects?: boolean; /** De-duplicate and remove unreachable `switch` branches. */ switches?: boolean; /** Drop unreferenced functions (\"funcs\") and/or variables (\"vars\") in the top level scope (false by default, true to drop both unreferenced functions and variables) */ toplevel?: boolean; /** Prevent specific toplevel functions and variables from unused removal (can be array, comma-separated, RegExp or function. Implies toplevel) */ top_retain?: boolean; typeofs?: boolean; unsafe?: boolean; /** Compress expressions like a `&lt;= b` assuming none of the operands can be (coerced to) `NaN`. */ unsafe_comps?: boolean; /** Compress and mangle `Function(args, code)` when both args and code are string literals. */ unsafe_Function?: boolean; /** Optimize numerical expressions like `2 * x * 3` into `6 * x`, which may give imprecise floating point results. */ unsafe_math?: boolean; /** Optimize expressions like `Array.prototype.slice.call(a)` into `[].slice.call(a)` */ unsafe_proto?: boolean; /** Enable substitutions of variables with `RegExp` values the same way as if they are constants. */ unsafe_regexp?: boolean; unsafe_undefined?: boolean; unused?: boolean; /** display warnings when dropping unreachable code or unused declarations etc. */ warnings?: boolean;&#125;","tags":"webpack@4+"},{"title":"require","url":"/41266748/","text":"前言在node开发或者前端工程化开发共，经常会需要用到require这个方法去加载一个文件，我们所认识的require似乎仅仅只有这一个功能，然而nodejs真的仅仅如此吗？require似乎并没有那么简单，只是我们了解的简单而已。 详细介绍 定义我们先来看下关于require的接口定义1234567891011121314151617181920212223242526272829303132333435363738interface NodeRequireFunction &#123; (id: string): any;&#125;interface NodeRequire extends NodeRequireFunction &#123; resolve: RequireResolve; cache: any; /** * @deprecated */ extensions: NodeExtensions; main: NodeModule | undefined;&#125;interface RequireResolve &#123; (id: string, options?: &#123; paths?: string[]; &#125;): string; paths(request: string): string[] | null;&#125;interface NodeExtensions &#123; '.js': (m: NodeModule, filename: string) =&gt; any; '.json': (m: NodeModule, filename: string) =&gt; any; '.node': (m: NodeModule, filename: string) =&gt; any; [ext: string]: (m: NodeModule, filename: string) =&gt; any;&#125;declare var require: NodeRequire;interface NodeModule &#123; exports: any; require: NodeRequireFunction; id: string; filename: string; loaded: boolean; parent: NodeModule | null; children: NodeModule[]; paths: string[];&#125; 从定义中看，我们会发现require除了可以用作方法外，还有四个额外的属性: extensions：require支持的ext列表 cache：require缓存，多次require同一个文件会从cache中读取，并不会重新读取，因此在某些情况下并不会重新创建实例，如果想要清除cache，需要使用delete去删除cache中的key，直接置空会失效 main：可以当做入口文件的对应模块 filename：入口文件名 其他一般不会使用，用到时再进行备注 resolve：返回引用的（模块的入口文件或者文件）的绝对路径，通常我们需要用到fs读取模块中的某个文件，却不清楚模块安装位置时（可能全局安装、可能在/node_modules中，也可能在某个模块的子node_modules中），可以使用该方式去获取","tags":"node require"},{"title":"performance","url":"/82d79681/","text":"前言H5 项目中经常涉及到性能优化，此时需要知道页面的性能指数，并上报统计，如何知道页面的性能指数对于很多前端开发人员来说比较迷茫，本文提供一段统一的代码，统计并打印出该页面所有耗时。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546window.addEventListener(\"load\",function () &#123; const performance = window.performance; if (performance) &#123; let e = performance.getEntriesByType('navigation')[0]; let r = 0; e || (r = (e = performance.timing).navigationStart); const n = [&#123; key: 'Redirect', desc: '\\u7f51\\u9875\\u91cd\\u5b9a\\u5411\\u7684\\u8017\\u65f6', value: e.redirectEnd - e.redirectStart &#125;, &#123; key: 'AppCache', desc: '\\u68c0\\u67e5\\u672c\\u5730\\u7f13\\u5b58\\u7684\\u8017\\u65f6', value: e.domainLookupStart - e.fetchStart &#125;, &#123; key: 'DNS', desc: 'DNS\\u67e5\\u8be2\\u7684\\u8017\\u65f6', value: e.domainLookupEnd - e.domainLookupStart &#125;, &#123; key: 'TCP', desc: 'TCP\\u8fde\\u63a5\\u7684\\u8017\\u65f6', value: e.connectEnd - e.connectStart &#125;, &#123; key: 'Waiting(TTFB)', desc: '\\u4ece\\u5ba2\\u6237\\u7aef\\u53d1\\u8d77\\u8bf7\\u6c42\\u5230\\u63a5\\u6536\\u5230\\u54cd\\u5e94\\u7684\\u65f6\\u95f4 / Time To First Byte', value: e.responseStart - e.requestStart &#125;, &#123; key: 'Content Download', desc: '\\u4e0b\\u8f7d\\u670d\\u52a1\\u7aef\\u8fd4\\u56de\\u6570\\u636e\\u7684\\u65f6\\u95f4', value: e.responseEnd - e.responseStart &#125;, &#123; key: 'HTTP Total Time', desc: 'http\\u8bf7\\u6c42\\u603b\\u8017\\u65f6', value: e.responseEnd - e.requestStart &#125;, &#123; key: 'DOMContentLoaded', desc: 'dom\\u52a0\\u8f7d\\u5b8c\\u6210\\u7684\\u65f6\\u95f4', value: e.domContentLoadedEventEnd - r &#125;, &#123; key: 'Loaded', desc: '\\u9875\\u9762load\\u7684\\u603b\\u8017\\u65f6', value: e.loadEventEnd - r &#125;]; console &amp;&amp; console.table &amp;&amp; console.table(n) &#125;&#125;);","tags":"h5 performance"},{"title":"umi.js","url":"/a96cfee5/","text":"definePlugins 中参数：‘process.env’: { NODE_ENV: ‘“production”‘ }, ‘process.env.BASE_URL’: ‘“/“‘, __IS_BROWSER: ‘false’, __UMI_BIGFISH_COMPAT: undefined, __UMI_HTML_SUFFIX: ‘false’ 通过 __IS_BROWSER 可以配置ssr 对应的webpack配置，及代码中环境判断，仅在编译环境有效， umi 和 egg-bin 命令出现部分ts或es6文件转换失败，是因为umi-core/lib/registerBabel中配置了babel转换属性only，但是在umi中并没有传递extra属性过去","tags":""},{"title":"DOM resize listener","url":"/27302137/","text":"iframe resizeObserver ，详见observer","tags":""},{"title":"图片懒加载","url":"/f0e261b6/","text":"前言随着H5页面图片资源的丰富，首屏页面加载效率受到明显限制，因此优化图片加载成为一个重要的需求，而图片的优化，除了压缩、缓存外，还有一个重要的方式是懒加载。本文主要介绍懒加载的实现方案及思路。 简介懒加载从字面看，就是我比较懒，你催我要的时候我才加载，不然我就罢工休息，因此主要的做法就是一开始不显示图片，在需要的时候我才加载并显示图片。什么时候才是需要的时候呢？从UI交互上讲就是图片所在的元素容器显示在viewport上的时候。因此设计方案如下： 实现方案 默认情况下img标签不设置src属性，仅做占位使用。 当该img元素被移动到可视区域viewport中时设置其src属性为需要访问的图片地址。 图片显示后回收对该图片的监听，释放资源 第一步比较简单，在js或者模板中，生成img时，使用data-src属性替代src属性即可，关键是第二步和第三步，如何去监听及释放。从掌握的前端知识中可以发现，有两种方式可以实现上面的逻辑： 方案一：Observer详细了解浏览器Observer的用法，我们可以发现有一个Intersection Observer能够观察元素位置，同时支持取消观察的API，满足当前需求，因此可以实现为： 1234&lt;img data-lazyload data-src=\"img-1.jpg\"&gt;&lt;img data-lazyload data-src=\"img-2.jpg\"&gt;&lt;img data-lazyload data-src=\"img-3.jpg\"&gt;&lt;!-- more images --&gt; 12345678const callback = (entries, observer)=&gt; &#123; entries.forEach(entry =&gt; &#123; entry.target.src = entry.target.dataset.src; observer.unobserve(entry.target);// 取消观察 &#125;);&#125;;const lazyLoadObserver = new IntersectionObserver(callback);document.querySelectorAll('[data-lazyload]').forEach(img =&gt; &#123; lazyLoadObserver.observe(img) &#125;); 到此，基本功能已经实现了，可以看到代码非常简单，配合相关的框架生成html的方式使用即可，但是经过测验会发现，图片在滚动到viewport中时，会存在较长时间的无图现象，对于用户感知来说，不太友好，因此需要将观察区域进行延伸，修改为如下： 12345678const callback = (entries, observer)=&gt; &#123; entries.forEach(entry =&gt; &#123; entry.target.src = entry.target.dataset.src; observer.unobserve(entry.target);// 取消观察 &#125;);&#125;;const lazyLoadObserver = new IntersectionObserver(callback,&#123;rootMargin:\"-50px 0 -50px 0\"&#125;);document.querySelectorAll('[data-lazyload]').forEach(img =&gt; &#123; lazyLoadObserver.observe(img) &#125;); 添加rootMargin参数，将观察区域相对于root进行放大，滚动时，当图片元素具体可视区域上或者下50px的位置时即可触发观察回调，此时立即进行图片加载，在一定的程度上，当用户将该图片滚动到可视区域中时，可能已经加载完成；具体的偏移值需要根据图片服务情况及用户网络情况确定。将上述代码用于项目中会发现，部分环境IntersectionObserver报错，这是由于兼容性造成，Observer中详细介绍了其兼容性并提供了polyfill方案，其polyfill和下面第二种方案类似。 方案二：onscroll + getComputedStyle传统js中判断元素与可视区域之间的位置关系用getBoundingClientRectAPI 来实现，因此，我们可以使用轮询判断的方式去进行元素探测，使用onscroll+getBoundingClientRect实现该功能： 123456789101112const imgs = document.querySelectorAll('[data-lazyload]');const callback = ()=&gt; &#123; imgs.forEach((img:HTMLImageElement) =&gt; &#123; if(!img.src)&#123; const position = img.getBoundingClientRect(); if(position.bottom&gt;=-50||position&lt;=window.innerHeight+50)&#123; img.src = img.dataset.src; &#125; &#125; &#125;);&#125;;window.addEventListener(\"scroll\",callback); 代码相当简单，但是并不实用，主要存在以下问题： - onscroll触发太过频繁，每次触发都去进行dom List的遍历，开销很大 - getBoundingClientRect容易造成浏览器重绘 - onscroll在IOS中并不会频繁触发，只在开始和结束触发一次 根据以上问题，需要对此进行优化： - 通过throttle或debounce优化onscroll的频繁触发 - 当onscroll触发不正常时，即判断IOS环境，使用requestAnimationFrame无限轮询代替onscroll优化代码此处不作提现，经过上面的优化，该方案可用性才明显提升。 注意 image 初始不要设置src属性，即使设置为&quot;&quot;或者undefined也不要，可能会造成重复载入，不同浏览器行为不一致 其他优化 通过滚动距离进行节流 滚动暂停时才开始触发探测回调 总结常见的一下lazyload插件主要采用的是方案二的方式，只是或多或少在此基础上做了进一步优化，但是其效率仍然比不上方案一，建议使用方案一，实在不兼容的情况下使用方案二。","tags":"h5 lib lazyload"},{"title":"Javascript设计模式","url":"/4caa003b/","text":"观察者模式：浏览器自带的四大观察者Intersection Observer，交叉观察者。 - Mutation Observer，变动观察者。 - Resize Observer，视图观察者。 - Performance Observer，性能观察者。","tags":""},{"title":"前端埋点实现","url":"/8e6ad7f6/","text":"兴趣埋点方案：位于屏幕中间，并停留时长大于2秒，计数一次。 区域悬停，触发定时器记录时间。 PC端记录鼠标点击次数/悬停时间，移动端记录touch事件 这里就不展开写了（我懒）。","tags":""},{"title":"前端异常监控","url":"/ff61036/","text":"","tags":""},{"title":"Observer API","url":"/e4278974/","text":"前言前端项目中经常需要用到异常监控和埋点功能，虽然大部分情况下我们都会直接接入第三方平台，因为第三方平台相对简单、稳定，通过第三方平台提供的API便可以简单实现服务注册及上报；很少我们会自己去开发一个自己的系统，但是，了解如何去开发异常监控和埋点功能还是非常有必要的。本文不针对方案进行详细介绍，如果有兴趣，可以转到前端异常监控和前端埋点实现详细了解。在思考方案过程中，我们想到了Javascript中的设计模式，观察者模式中提到浏览器自带的观察者如下： 1、Intersection Observer，交叉观察者。2、Mutation Observer，变动观察者。3、Resize Observer，视图观察者。4、Performance Observer，性能观察者。 简介 &emsp;&emsp; Intersection Observer Mutation Observer Resize Observer Performance Observer 作用 观察一个元素是否在viewport中可视 观察DOM中的变化 观察DOM元素大小的变化 检测性能度量事件 方法 observe()disconnect()takeRecords()unobserve() observe()disconnect()takeRecords()unobserve() observe()disconnect()unobserve() observe()disconnect()takeRecords() 替代 DOM Mutation events getBoundingRect()返回元素大小及其相对于viewport的位置Scroll和Resize事件 Resize事件 Performance接口 场景 1.无限滚动2.图片懒加载3.兴趣埋点4.控制动画、视频执行（性能优化） 1.更高性能的数据绑定和响应2.实现视觉差滚动3.图片预加载4.富文本编辑器实现 1.更智能的响应式布局（取代@media）2.响应式组件 1.更细颗粒的性能检测2.分析性能对业务的影响 详细介绍Intersection Observer：交叉观察者 IntersectionObserver接口，提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法，祖先元素与视窗(viewport)被称为根(root) 意义：想要实时计算Web页面元素的位置，并根据位置进行交互控制，从而实现前端性能优化，这方面的实现非常依赖于DOM状态的显示查询，但这些查询是同步的，会导致昂贵的样式计算开销（重绘和回流），且不停轮询会导致大量的性能浪费。早起针对此问题有以下几种方案： 定时器轮询计算每个元素的实时可见性 基于享元模式实现数据绑定的高性能滚动列表，列表中呈现的是数据集的子集 通过onscroll事件实时计算元素的可见性这些方案存在以下共同点： 都是查询各个元素相对与某些元素（全局视口）的“被动查询”。过度增长的CPU使用，牺牲CPU提升性能。 优势：Intersection Observer API通过为开发人员提供一种新方法来异步查询元素相对于其他元素或全局视口的位置，从而解决了上述问题: 异步处理消除了昂贵的DOM和样式查询，连续轮询以及使用自定义scroll插件的需求。 使应用程序显着降低CPU，GPU和资源成本。 基本使用： 创建观察者： 123456const options = &#123; root: document.querySelector('.scrollContainer'), rootMargin: '0px', threshold: [0.3, 0.5, 0.8, 1] &#125;;const observer = new IntersectionObserver(handler, options) 配置参数的含义：root：指定根元素即观察区域元素rootMargin：通过类似css margin的值设置观察区域相对于root大小的扩展threshold：阈值，number或Array&lt;number&gt;，指定当目标元素在root指定区域内，当可见度等于阈值时触发调度函数 定义回调事件当目标与根元素通过阈值相交时，就会触发回调函数。 12345678910111213141516171819202122interface IntersectionObserverEntry &#123; readonly boundingClientRect: ClientRect | DOMRect; readonly intersectionRatio: number; readonly intersectionRect: ClientRect | DOMRect; readonly isIntersecting: boolean; readonly rootBounds: ClientRect | DOMRect | null; readonly target: Element; readonly time: number;&#125;function handler (entries:IntersectionObserverEntry[], observer) &#123; entries.forEach(entry =&gt; &#123; // 每个成员都是一个IntersectionObserverEntry对象。 // 举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。 // entry.boundingClientRect // entry.intersectionRatio // entry.intersectionRect // entry.isIntersecting // entry.rootBounds // entry.target // entry.time &#125;); &#125; time：返回交叉被触发的时间的时间戳，可见性发生变化的时间，是一个高精度时间戳，单位为毫秒rootBounds：返回包含根元素的矩形区域的信息boundingClientRect：返回包含目标元素的矩形区域的信息，边界的计算方式与 getBoundingClientRect() 相同intersectionRect： 返回根元素和目标元素的交叉区域的信息intersectionRatio： 返回目标元素的可见比例,也就是 intersectionRect 占 boundingClientRect 的比例值，见下图target：返回目标元素的 dom 节点对象isIntersecting：目标元素是否与根元素相交 定义观察目标对象任何目标元素都可以通过调用.observer(target)方法来观察。 12const target = document.querySelector(\".targetBox\"); observer.observe(target); 此外，还有两个停止监听的方法方法： 12observer.unobserve(target);// 停止对某目标的监听observer.disconnect();// 终止对所有目标的监听 示例1：图片懒加载 1234&lt;img src=\"placeholder.png\" data-src=\"img-1.jpg\"&gt;&lt;img src=\"placeholder.png\" data-src=\"img-2.jpg\"&gt;&lt;img src=\"placeholder.png\" data-src=\"img-3.jpg\"&gt;&lt;!-- more images --&gt; 123456789const callback = (entries, observer)=&gt; &#123; entries.forEach(entry =&gt; &#123; /* 替换属性 */ entry.target.src = entry.target.dataset.src; observer.unobserve(entry.target); &#125;);&#125;;let observer = new IntersectionObserver(callback,&#123;rootMargin: \"0px 0px -200px 0px\"&#125;);document.querySelectorAll('img').forEach(img =&gt; &#123; observer.observe(img) &#125;); html中通过js遍历或模板方式输出一批图片元素，其src属性指定为固定的logo或者占位图，并设置其data-src属性为真实图片地址，在js中通过观察器观察，当图片进入窗口区域底部200px位置时开始替换属性加载真实图片并且回收该元素监听。当然由于API兼容性问题，真实的图片懒加载不可能只有这么多代码，如要考虑在API不兼容的情况下，通过scroll事件和节流消抖来轮询检测元素位置，具体参考图片懒加载。 示例2：兴趣埋点关于兴趣埋点，一个比较通用的方案是： 来自：《超好用的API之IntersectionObserver》 1234567891011121314151617const boxList = [...document.querySelectorAll('.box')];var io = new IntersectionObserver((entries) =&gt;&#123; entries.forEach(item =&gt; &#123; // intersectionRatio === 1说明该元素完全暴露出来，符合业务需求 if (item.intersectionRatio === 1) &#123; // TODO 埋点曝光代码 io.unobserve(item.target) &#125; &#125;)&#125;, &#123; root: null, threshold: 1, // 阀值设为1，当只有比例达到1时才触发回调函数&#125;);// observe遍历监听所有box节点boxList.forEach(box =&gt; io.observe(box)); 至于怎样评断用户是否感兴趣，方案就多种多样了，此处不作叙述，需要可以查看埋点 示例3：控制动画视频执行这是一个比较常见的场景，如果h5列表元素中包含动画或视频，此优化是必须的，经常在面试中也会问到此类问题，此处介绍视频的控制： 1&lt;video src=\"OSRO-animation.mp4\" controls=\"\"&gt;&lt;/video&gt; 1234567891011let video = document.querySelector('video');let isPaused = false; /* Flag for auto-paused video */let observer = new IntersectionObserver((entries, observer) =&gt; &#123; entries.forEach(entry =&gt; &#123; if(entry.intersectionRatio!=1 &amp;&amp; !video.paused)&#123; video.pause(); isPaused = true; &#125; else if(isPaused) &#123;video.play(); isPaused=false&#125; &#125;);&#125;, &#123;threshold: 1&#125;);observer.observe(video); 这只是简单的实现，当然页面中有多个视频组成视频列表时还需要控制什么情况下才开始播放，播放中的视频仅能有一个，否则出现混乱，影响用户体验。 Mutation Observer：变动观察者 接口提供了监视对DOM树所做更改的能力。它被设计为旧的MutationEvents功能的替代品，该功能是DOM3 Events规范的一部分。 意义归根究底，是MutationEvents的功能不尽人意： 在MDN中也写到了，是由于DOM Event承认在API上有缺陷，反对使用。核心缺陷是：性能问题和跨浏览器支持。为DOM添加 mutation 监听器极度降低进一步修改DOM文档的性能（慢1.5 - 7倍），此外, 移除监听器不会逆转的损害。 MutationEvents的原理：通过绑定事件监听DOM，支持的事件大致如下，不同浏览器存在兼容性差异，不需要去记录他们 12345678DOMAttributeNameChangedDOMCharacterDataModifiedDOMElementNameChangedDOMNodeInsertedDOMNodeInsertedIntoDocumentDOMNodeRemovedDOMNodeRemovedFromDocumentDOMSubtreeModified 优势 MutationEvents事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件； Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。 可以通过配置项，监听目标DOM下子元素的变更记录 基本使用 创建观察者 1let observer = new MutationObserver(callback); 定义回调函数上面代码中的回调函数，会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例，下面是一个例子： 12345678910111213141516interface MutationRecord &#123; readonly addedNodes: NodeList; readonly attributeName: string | null; readonly attributeNamespace: string | null; readonly nextSibling: Node | null; readonly oldValue: string | null; readonly previousSibling: Node | null; readonly removedNodes: NodeList; readonly target: Node; readonly type: MutationRecordType;&#125;function callback (mutations:MutationRecord[], observer) &#123; mutations.forEach(function(mutation) &#123; console.log(mutation); &#125;);&#125; MutationRecord对象中各属性含义如下： 属性 意义 type 观察的变动类型（attribute、characterData或者childList） target 发生变动的DOM节点 addedNodes 新增的DOM节点 removedNodes 删除的DOM节点 previousSibling 前一个同级节点，如果没有则返回null nextSibling 下一个同级节点，如果没有则返回null attributeName 发生变动的属性。如果设置了attributeFilter，则只返回预先指定的属性 oldValue 变动前的值。这个属性只对attribute和characterData变动有效，如果发生childList变动，则返回null 定义要观察的目标 123456789101112131415161718interface MutationObserverInit &#123; attributeFilter?: string[]; attributeOldValue?: boolean; attributes?: boolean; characterData?: boolean; characterDataOldValue?: boolean; childList?: boolean; subtree?: boolean;&#125;mutationObserver.observe(content, &#123; attributes: true, // Boolean - 观察目标属性的改变 characterData: true, // Boolean - 观察目标数据的改变(改变前的数据/值) childList: true, // Boolean - 观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化 subtree: true, // Boolean - 目标以及目标的后代改变都会观察 attributeOldValue: true, // Boolean - 表示需要记录改变前的目标属性值 characterDataOldValue: true, // Boolean - 设置了characterDataOldValue可以省略characterData设置 // attributeFilter: ['src', 'class'] // Array - 观察指定属性&#125;); 优先级如下： 1、attributeFilter/attributeOldValue &gt; attributes2、characterDataOldValue &gt; characterData3、attributes/characterData/childList（或更高级特定项）至少有一项为true；4、特定项存在, 对应选项可以忽略或必须为true 此外，还有两个停止观察的方法： 123mutationObserver.unobserve(target);// 取消观察某个元素mutationObserver.disconnect();// 全部取消观察mutationObserver.takeRecords();// 清除变动记录。即不再处理未处理的变动。该方法返回变动记录的数组，注意，该方法立即生效。 例子1：监听文本变化 12345678const target = document.getElementById('target-id');const observer = new MutationObserver(records =&gt; &#123; // 输入变更记录&#125;);// 开始观察observer.observe(target, &#123; characterData: true&#125;) 这里可以有几种处理。 聊天的气泡框彩蛋，检测文本中的指定字符串/表情包，触发类似微信聊天的表情落下动画。 输入框的热点话题搜索，当输入”#”号时，启动搜索框预检文本或高亮话题。 有个Vue的小型插件就是这么实现的： 来自：《vue-hashtag-textarea》 ResizeObserver，视图观察者ResizeObserver API是一个新的JavaScript API，与IntersectionObserver API非常相似，它们都允许我们去监听某个元素的变化。 意义： 开发过程当中经常遇到的一个问题就是如何监听一个 div 的尺寸变化。 但众所周知，为了监听 div 的尺寸变化，都将侦听器附加到 window 中的 resize 事件。 但这很容易导致性能问题，因为大量的触发事件。 换句话说，使用window.resize 通常是浪费的，因为它告诉我们每个视窗大小的变化，而不仅仅是当一个元素的大小发生变化。 而且resize事件会在一秒内触发将近60次，很容易在改变窗口大小时导致性能问题，比如说，你要调整一个元素的大小，那就需要在 resize 的回调函数 callback() 中调用 getBoundingClientRect 或 getComputerStyle。不过你要是不小心处理所有的读和写操作，就会导致布局混乱。 优势 细颗粒度的DOM元素观察，而不是window，当然是用resize也可以实现单个元素的监听，具体方案参考DOM resize listener 没有额外的性能开销，只会在绘制前或布局后触发调用 基本使用 创建观察者 1let observer = new ResizeObserver(callback); 定义回调函数 123456789 interface ResizeObserverEntry &#123; readonly contentRect: DOMRectReadOnly; readonly target: Element; &#125;const callback = (entries:ResizeObserverEntry[]) =&gt; &#123; entries.forEach(entry =&gt; &#123; &#125;)&#125; 定义要观察的目标 1observer.observe(document.body) 此外，取消观察的api有： 12observer.unobserve(document.body);// 取消特定元素observer.disconnect();// 全部取消 例子1：响应式组件前端响应式组件通常是使用@media去实现的，但是@media仅能监控窗口大小，不能监控元素本身大小，如果布局发生改变，@media的响应式会存在一些问题，完美的响应式组件是监控元素本身大小，例如vue-responsive-components库的实现，就是通过ResizeObserver观察元素本身大小变化从而实现响应式。 PerformanceObserver：性能观察者这是一个浏览器和Node.js 里都存在的API，采用相同W3C的Performance Timeline规范 在浏览器中，我们可以使用 window 对象取得window.performance和 window.PerformanceObserver 。 而在 Node.js 程序中需要perf_hooks 取得性能对象，如下：const { PerformanceObserver, performance } = require(&#39;perf_hooks&#39;); 意义： 可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API Performance API 是大家熟悉的一个接口，他记录着几种性能指数的庞大对象集合1234567891011121314151617181920212223242526272829303132333435363738394041424344454647interface PerformanceTiming &#123; readonly connectEnd: number; readonly connectStart: number; readonly domComplete: number; readonly domContentLoadedEventEnd: number; readonly domContentLoadedEventStart: number; readonly domInteractive: number; readonly domLoading: number; readonly domainLookupEnd: number; readonly domainLookupStart: number; readonly fetchStart: number; readonly loadEventEnd: number; readonly loadEventStart: number; readonly navigationStart: number; readonly redirectEnd: number; readonly redirectStart: number; readonly requestStart: number; readonly responseEnd: number; readonly responseStart: number; readonly secureConnectionStart: number; readonly unloadEventEnd: number; readonly unloadEventStart: number; toJSON(): any;&#125;interface Performance extends EventTarget &#123; /** @deprecated */ readonly navigation: PerformanceNavigation; onresourcetimingbufferfull: ((this: Performance, ev: Event) =&gt; any) | null; readonly timeOrigin: number; /** @deprecated */ readonly timing: PerformanceTiming; clearMarks(markName?: string): void; clearMeasures(measureName?: string): void; clearResourceTimings(): void; getEntries(): PerformanceEntryList; getEntriesByName(name: string, type?: string): PerformanceEntryList; getEntriesByType(type: string): PerformanceEntryList; mark(markName: string): void; measure(measureName: string, startMark?: string, endMark?: string): void; now(): number; setResourceTimingBufferSize(maxSize: number): void; toJSON(): any; addEventListener&lt;K extends keyof PerformanceEventMap&gt;(type: K, listener: (this: Performance, ev: PerformanceEventMap[K]) =&gt; any, options?: boolean | AddEventListenerOptions): void; addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void; removeEventListener&lt;K extends keyof PerformanceEventMap&gt;(type: K, listener: (this: Performance, ev: PerformanceEventMap[K]) =&gt; any, options?: boolean | EventListenerOptions): void; removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;&#125; Performance API若想获得某项页面加载性能记录，就需要调用performance.getEntries或者performance.getEntriesByName来获得。 Performance API而获得执行效率，也只能通过performance.now来计算。 优势PerformanceObserver是浏览器内部对Performance实现的观察者模式，也是现代浏览器支持的几个 Observer 之一。 来自：《你了解 Performance Timeline Level 2 吗？》 它解决了以下3点问题： 避免不知道性能事件啥时候会发生，需要重复轮训timeline获取记录。避免产生重复的逻辑去获取不同的性能数据指标避免其他资源需要操作浏览器性能缓冲区时产生竞态关系。 W3C官网文档鼓励开发人员尽可能使用PerformanceObserver，而不是通过Performance获取性能参数及指标。 使用 创建观察者 1let observer = new PerformanceObserver(callback); 定义回调函数 1234567891011121314151617interface PerformanceObserverEntryList &#123; getEntries(): PerformanceEntryList; getEntriesByName(name: string, type?: string): PerformanceEntryList; getEntriesByType(type: string): PerformanceEntryList;&#125;interface PerformanceEntry &#123; readonly duration: number; readonly entryType: string; readonly name: string; readonly startTime: number; toJSON(): any;&#125;const callback = (list:PerformanceObserverEntryList, observer) =&gt; &#123; const entries = list.getEntries(); entries.forEach((entry:PerformanceEntry) =&gt; &#123; &#125;);&#125; 定义要观察的目标对象 123456interface PerformanceObserverInit &#123; buffered?: boolean; entryTypes?: string[]; type?: string;&#125;observer.observe(&#123;entryTypes: [\"entryTypes\"]&#125; as PerformanceObserverInit); observer.observe(...)方法接受可以观察到的有效的入口类型。这些输入类型可能属于各种性能API，比如User Tming或Navigation Timing API。有效的entryType值： 属性 别名 类型 描述 framenavigation PerformanceFrameTimingPerformanceNavigationTiming URL 文件的地址 resource PerformanceResourceTiming URL 所请求资源的解析URL mark PerformanceMark DOMString 通过调用创建标记时使用的名称performance.mark() measure PerformanceMeasure DOMString 通过调用创建度量时使用的名称performance.measure() paint PerformancePaintTiming DOMString 无论是first-paint或first-contentful-paint longtask PerformanceLongTaskTiming DOMString 报告长任务的实例 例子：静态资源监控 来自：《资源监控》 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function filterTime(a, b) &#123; return (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; (a - b) &gt;= 0) ? (a - b) : undefined;&#125;let resolvePerformanceTiming = (timing) =&gt; &#123; let o = &#123; initiatorType: timing.initiatorType, name: timing.name, duration: parseInt(timing.duration), redirect: filterTime(timing.redirectEnd, timing.redirectStart), // 重定向 dns: filterTime(timing.domainLookupEnd, timing.domainLookupStart), // DNS解析 connect: filterTime(timing.connectEnd, timing.connectStart), // TCP建连 network: filterTime(timing.connectEnd, timing.startTime), // 网络总耗时 send: filterTime(timing.responseStart, timing.requestStart), // 发送开始到接受第一个返回 receive: filterTime(timing.responseEnd, timing.responseStart), // 接收总时间 request: filterTime(timing.responseEnd, timing.requestStart), // 总时间 ttfb: filterTime(timing.responseStart, timing.requestStart), // 首字节时间 &#125;; return o;&#125;;let resolveEntries = (entries) =&gt; entries.map(item =&gt; resolvePerformanceTiming(item));let resources = &#123; init: (cb) =&gt; &#123; let performance = window.performance || window.mozPerformance || window.msPerformance || window.webkitPerformance; if (!performance || !performance.getEntries) &#123; return void 0; &#125; if (window.PerformanceObserver) &#123; let observer = new window.PerformanceObserver((list) =&gt; &#123; try &#123; let entries = list.getEntries(); cb(resolveEntries(entries)); &#125; catch (e) &#123; console.error(e); &#125; &#125;); observer.observe(&#123; entryTypes: ['resource'] &#125;) &#125; else &#123; window.addEventListener('load', () =&gt; &#123; let entries = performance.getEntriesByType('resource'); cb(resolveEntries(entries)); &#125;); &#125; &#125;,&#125;; 参考文章 资源监控 Media Queries Based on Element Width with MutationObserver 以用户为中心的性能指标 A Few Functional Uses for Intersection Observer to Know When an Element is in View Getting To Know The MutationObserver API Different Types Of Observers Supported By Modern Browsers THE RESIZE OBSERVER EXPLAINED A Look at the Resize Observer JavaScript API 兼容性Intersection Observer | Mutation Observer | Resize Observer | Performance Observer 总结这四个观察者，都非常适合集成到监控系统。虽然其兼容性有一定的限制，但是都有对应的polyfills：Intersection Observer：intersection-observerMutation Observer：mutationobserver-shimResize Observer：resize-observer-polyfillPerformance Observer：@fastly/performance-observer-polyfill","tags":""},{"title":"Tree Structure","url":"/e06277db/","text":"","tags":"data-structure algorithm"},{"title":"Babel","url":"/7056c18d/","text":"babel-plugin-module-resolver 插件的妙用 babel 中typescript 不支持enum 等，但是rn的presetmetro-react-native-babel-preset中却支持，可以研究","tags":""},{"title":"AST","url":"/7389a59f/","text":"前言提起 AST 抽象语法树，大家可能并不感冒，认为它和你的领域没有多少交集。但是提到它的使用场景，也许会让你大吃一惊。原来它一直在你左右与你相伴，而你却不知。 简介在计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码，例如less、sass、ES6、typescript、js等源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。 作用前面说AST树一直伴随着我们左右，其实只要涉及到词法分析或语法分析的都会使用它，例如各种代码编辑、编译器，代码转换器（工具）等，而在前端中，我们接触到的功能主要有以下几种： JS反编译，语法分析 Babel编译ES6语法，Babel插件 代码高亮 关键字匹配 作用域判断 代码压缩 代码转换 代码补全 etc… AST Explorer由于语法树一直以来比较抽象，没有一个比较好的方式去学习了解它，我们通常了解语法树的结构是通过AST Explorer去查看相关的树结构。其中几乎支持所有前端语法，除部分预编译语言，如less、sass、stylus等。通过该解释器，我们先观察一个简单的ES6代码： 1let messages=[\"I'm a student!\"]; 生成的JSON格式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; &quot;type&quot;: &quot;Program&quot;, &quot;start&quot;: 0, &quot;end&quot;: 32, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclaration&quot;, &quot;start&quot;: 0, &quot;end&quot;: 32, &quot;declarations&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclarator&quot;, &quot;start&quot;: 4, &quot;end&quot;: 31, &quot;id&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 4, &quot;end&quot;: 12, &quot;name&quot;: &quot;messages&quot; &#125;, &quot;init&quot;: &#123; &quot;type&quot;: &quot;ArrayExpression&quot;, &quot;start&quot;: 13, &quot;end&quot;: 31, &quot;elements&quot;: [ &#123; &quot;type&quot;: &quot;Literal&quot;, &quot;start&quot;: 14, &quot;end&quot;: 30, &quot;value&quot;: &quot;I&apos;m a student!&quot;, &quot;raw&quot;: &quot;\\&quot;I&apos;m a student!\\&quot;&quot; &#125; ] &#125; &#125; ], &quot;kind&quot;: &quot;let&quot; &#125; ], &quot;sourceType&quot;: &quot;module&quot;&#125; 而他的语法树如下： 我们发现AST语法树和DOM树很类似，都是树形结构，结构层次清清楚楚。 再看一个expression的例子： 1(1+2)*3 JSON格式如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;type&quot;: &quot;Program&quot;, &quot;start&quot;: 0, &quot;end&quot;: 7, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;ExpressionStatement&quot;, &quot;start&quot;: 0, &quot;end&quot;: 7, &quot;expression&quot;: &#123; &quot;type&quot;: &quot;BinaryExpression&quot;, &quot;start&quot;: 0, &quot;end&quot;: 7, &quot;left&quot;: &#123; &quot;type&quot;: &quot;BinaryExpression&quot;, &quot;start&quot;: 1, &quot;end&quot;: 4, &quot;left&quot;: &#123; &quot;type&quot;: &quot;Literal&quot;, &quot;start&quot;: 1, &quot;end&quot;: 2, &quot;value&quot;: 1, &quot;raw&quot;: &quot;1&quot; &#125;, &quot;operator&quot;: &quot;+&quot;, &quot;right&quot;: &#123; &quot;type&quot;: &quot;Literal&quot;, &quot;start&quot;: 3, &quot;end&quot;: 4, &quot;value&quot;: 2, &quot;raw&quot;: &quot;2&quot; &#125; &#125;, &quot;operator&quot;: &quot;*&quot;, &quot;right&quot;: &#123; &quot;type&quot;: &quot;Literal&quot;, &quot;start&quot;: 6, &quot;end&quot;: 7, &quot;value&quot;: 3, &quot;raw&quot;: &quot;3&quot; &#125; &#125; &#125; ], &quot;sourceType&quot;: &quot;module&quot;&#125; 对应的AST树如下： 将表达式的()删除，我们做个对比： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;type&quot;: &quot;Program&quot;, &quot;start&quot;: 0, &quot;end&quot;: 5, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;ExpressionStatement&quot;, &quot;start&quot;: 0, &quot;end&quot;: 5, &quot;expression&quot;: &#123; &quot;type&quot;: &quot;BinaryExpression&quot;, &quot;start&quot;: 0, &quot;end&quot;: 5, &quot;left&quot;: &#123; &quot;type&quot;: &quot;Literal&quot;, &quot;start&quot;: 0, &quot;end&quot;: 1, &quot;value&quot;: 1, &quot;raw&quot;: &quot;1&quot; &#125;, &quot;operator&quot;: &quot;+&quot;, &quot;right&quot;: &#123; &quot;type&quot;: &quot;BinaryExpression&quot;, &quot;start&quot;: 2, &quot;end&quot;: 5, &quot;left&quot;: &#123; &quot;type&quot;: &quot;Literal&quot;, &quot;start&quot;: 2, &quot;end&quot;: 3, &quot;value&quot;: 2, &quot;raw&quot;: &quot;2&quot; &#125;, &quot;operator&quot;: &quot;*&quot;, &quot;right&quot;: &#123; &quot;type&quot;: &quot;Literal&quot;, &quot;start&quot;: 4, &quot;end&quot;: 5, &quot;value&quot;: 3, &quot;raw&quot;: &quot;3&quot; &#125; &#125; &#125; &#125; ], &quot;sourceType&quot;: &quot;module&quot;&#125; 通过对比发现，括号限制了表达式的优先级，在AST树中影响的是left和right中的结构顺序： 在确定类型为ExpressionStatement后，它会按照代码执行的先后顺序，将表达式BinaryExpression分为left，operator 和 right 三块 left：表示一个运算符的左侧，可以是另一个表达式也可以是一个具体的值 right：表示一个运算符的右侧，可以是另一个表达式也可以是一个具体的值 left和right都标明了类型，起止位置，值等信息； operator定义操作运算符； 通过这样的结构我们可以自己实现复杂的expression的AST树，例如(a*b+c)/d： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; &quot;type&quot;: &quot;Program&quot;, &quot;start&quot;: 0, &quot;end&quot;: 9, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;ExpressionStatement&quot;, &quot;start&quot;: 0, &quot;end&quot;: 9, &quot;expression&quot;: &#123; &quot;type&quot;: &quot;BinaryExpression&quot;, &quot;start&quot;: 0, &quot;end&quot;: 9, &quot;left&quot;: &#123; &quot;type&quot;: &quot;BinaryExpression&quot;, &quot;start&quot;: 1, &quot;end&quot;: 6, &quot;left&quot;: &#123; &quot;type&quot;: &quot;BinaryExpression&quot;, &quot;start&quot;: 1, &quot;end&quot;: 4, &quot;left&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 1, &quot;end&quot;: 2, &quot;name&quot;: &quot;a&quot; &#125;, &quot;operator&quot;: &quot;*&quot;, &quot;right&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 3, &quot;end&quot;: 4, &quot;name&quot;: &quot;b&quot; &#125; &#125;, &quot;operator&quot;: &quot;+&quot;, &quot;right&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 5, &quot;end&quot;: 6, &quot;name&quot;: &quot;c&quot; &#125; &#125;, &quot;operator&quot;: &quot;/&quot;, &quot;right&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 8, &quot;end&quot;: 9, &quot;name&quot;: &quot;d&quot; &#125; &#125; &#125; ], &quot;sourceType&quot;: &quot;module&quot;&#125; 再来看看我们常用的箭头函数的AST树： 123const test = (a,b) =&gt; &#123; return a+b;&#125; JSON格式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&#123; &quot;type&quot;: &quot;Program&quot;, &quot;start&quot;: 0, &quot;end&quot;: 39, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclaration&quot;, &quot;start&quot;: 0, &quot;end&quot;: 39, &quot;declarations&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclarator&quot;, &quot;start&quot;: 6, &quot;end&quot;: 39, &quot;id&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 6, &quot;end&quot;: 10, &quot;name&quot;: &quot;test&quot; &#125;, &quot;init&quot;: &#123; &quot;type&quot;: &quot;ArrowFunctionExpression&quot;, &quot;start&quot;: 13, &quot;end&quot;: 39, &quot;id&quot;: null, &quot;expression&quot;: false, &quot;generator&quot;: false, &quot;async&quot;: false, &quot;params&quot;: [ &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 14, &quot;end&quot;: 15, &quot;name&quot;: &quot;a&quot; &#125;, &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 16, &quot;end&quot;: 17, &quot;name&quot;: &quot;b&quot; &#125; ], &quot;body&quot;: &#123; &quot;type&quot;: &quot;BlockStatement&quot;, &quot;start&quot;: 22, &quot;end&quot;: 39, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;ReturnStatement&quot;, &quot;start&quot;: 26, &quot;end&quot;: 37, &quot;argument&quot;: &#123; &quot;type&quot;: &quot;BinaryExpression&quot;, &quot;start&quot;: 33, &quot;end&quot;: 36, &quot;left&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 33, &quot;end&quot;: 34, &quot;name&quot;: &quot;a&quot; &#125;, &quot;operator&quot;: &quot;+&quot;, &quot;right&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 35, &quot;end&quot;: 36, &quot;name&quot;: &quot;b&quot; &#125; &#125; &#125; ] &#125; &#125; &#125; ], &quot;kind&quot;: &quot;const&quot; &#125; ], &quot;sourceType&quot;: &quot;module&quot;&#125; 对应的AST结构如下： 我们会发现，其中相对于上面的简单例子，又增加了几个新的类型： ArrowFunctionExpression BlockStatement ReturnStatement到这里，其实我们已经慢慢明白了：抽象语法树其实就是将一类标签转化成通用标识符，从而结构出的一个类似于树形结构的语法树，只要了解其语法树的格式，类型定义就能深入的理解AST。 深入原理AST Explorer 可视化工具能够让我们快速认知AST，那么这些可视化工具、编译器、转换插件内部是怎么实现的呢，我们来看一个例子： 1function getAST()&#123;&#125; 其JSON格式如下： 1234567891011121314151617181920212223242526272829&#123; &quot;type&quot;: &quot;Program&quot;, &quot;start&quot;: 0, &quot;end&quot;: 19, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;FunctionDeclaration&quot;, &quot;start&quot;: 0, &quot;end&quot;: 19, &quot;id&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 9, &quot;end&quot;: 15, &quot;name&quot;: &quot;getAST&quot; &#125;, &quot;expression&quot;: false, &quot;generator&quot;: false, &quot;async&quot;: false, &quot;params&quot;: [], &quot;body&quot;: &#123; &quot;type&quot;: &quot;BlockStatement&quot;, &quot;start&quot;: 17, &quot;end&quot;: 19, &quot;body&quot;: [] &#125; &#125; ], &quot;sourceType&quot;: &quot;module&quot;&#125; AST如下： 我们通过第三方模块esprima、estraverse、escodegen三个包来实现树的遍历 esprima : 一个将js代码解析成AST树的包 estraverse：遍历树的包 escodegen：生成新的AST树的包123456789101112131415161718const esprima = require('esprima'); //解析js的语法的包const estraverse = require('estraverse'); //遍历树的包const escodegen = require('escodegen'); //生成新的树的包let code = `function getAST()&#123;&#125;`;//解析js的语法let tree = esprima.parseScript(code);//遍历树estraverse.traverse(tree, &#123; enter(node) &#123; console.log('enter: ' + node.type); &#125;, leave(node) &#123; console.log('leave: ' + node.type); &#125;&#125;);//生成新的树let r = escodegen.generate(tree);console.log(r); 运行后输出结果为：12345678910enter: Programenter: FunctionDeclarationenter: Identifierleave: Identifierenter: BlockStatementleave: BlockStatementleave: FunctionDeclarationleave: Programfunction getAST() &#123;&#125; 可以发现遍历过程使用的是深度优先算法，当然我们也可以自己实现对应的遍历算方法，不过遍历算法需要支持所有的类型，否则遍历会出现问题，除非你仅需要针对特定类型进行处理，例如postcss中的提供的遍历API。通过遍历我们可以实现一定的代码转换功能，例如将上述函数名修改为newAST：123456789101112131415161718const esprima = require('esprima'); //解析js的语法的包const estraverse = require('estraverse'); //遍历树的包const escodegen = require('escodegen'); //生成新的树的包let code = `function getAST()&#123;&#125;`;//解析js的语法let tree = esprima.parseScript(code);//遍历树estraverse.traverse(tree, &#123; enter(node) &#123; console.log('enter: ' + node.type); if (node.type === 'Identifier') &#123; node.name = 'newAST'; &#125; &#125;&#125;);//生成新的树let r = escodegen.generate(tree);console.log(r); 运行后结果为：123456enter: Programenter: FunctionDeclarationenter: Identifierenter: BlockStatementfunction newAST() &#123;&#125; 可以看到，在我们的干预下，输出的结果发生了变化，方法名编译后方法名变成了newAST。这就是抽象语法树的强大之处，本质上通过编译，我们可以去改变任何输出结果。这也是大部分开发工具编译的核心，包括babel、less、sass、postcss前端常用转换工具等。 AST Node类型大致有以下集合： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657type INodeType= \"Identifier\" | \"SimpleLiteral\" | \"RegExpLiteral\" | \"Program\" | \"FunctionDeclaration\" | \"FunctionExpression\" | \"ArrowFunctionExpression\" | \"SwitchCase\" | \"CatchClause\" | \"VariableDeclarator\" | \"ExpressionStatement\" | \"BlockStatement\" | \"EmptyStatement\" | \"DebuggerStatement\" | \"WithStatement\" | \"ReturnStatement\" | \"LabeledStatement\" | \"BreakStatement\" | \"ContinueStatement\" | \"IfStatement\" | \"SwitchStatement\" | \"ThrowStatement\" | \"TryStatement\" | \"WhileStatement\" | \"DoWhileStatement\" | \"ForStatement\" | \"ForInStatement\" | \"ForOfStatement\" | \"VariableDeclaration\" | \"ClassDeclaration\" | \"ThisExpression\" | \"ArrayExpression\" | \"ObjectExpression\" | \"YieldExpression\" | \"UnaryExpression\" | \"UpdateExpression\" | \"BinaryExpression\" | \"AssignmentExpression\" | \"LogicalExpression\" | \"MemberExpression\" | \"ConditionalExpression\" | \"SimpleCallExpression\" | \"NewExpression\" | \"SequenceExpression\" | \"TemplateLiteral\" | \"TaggedTemplateExpression\" | \"ClassExpression\" | \"MetaProperty\" | \"AwaitExpression\" | \"Property\" | \"AssignmentProperty\" | \"Super\" | \"TemplateElement\" | \"SpreadElement\" | \"ObjectPattern\" | \"ArrayPattern\" | \"RestElement\" | \"AssignmentPattern\" | \"ClassBody\" | \"MethodDefinition\" | \"ImportDeclaration\" | \"ExportNamedDeclaration\" | \"ExportDefaultDeclaration\" | \"ExportAllDeclaration\" | \"ImportSpecifier\" | \"ImportDefaultSpecifier\" | \"ImportNamespaceSpecifier\" | \"ExportSpecifier\" | \"Directive\" | \"DirectiveLiteral\" | \"CallExpression\" | \"File\" | \"StringLiteral\" | \"NumericLiteral\" | \"NullLiteral\" | \"BooleanLiteral\" | \"ObjectMethod\" | \"ObjectProperty\" | \"ExportNamedDeclaration\" | \"ClassMethod\" | \"AnyTypeAnnotation\" | \"ArrayTypeAnnotation\" | \"BooleanTypeAnnotation\" | \"BooleanLiteralTypeAnnotation\" | \"NullLiteralTypeAnnotation\" | \"ClassImplements\" | \"ClassProperty\" | \"DeclareClass\" | \"DeclareFunction\" | \"DeclareInterface\" | \"DeclareModule\" | \"DeclareTypeAlias\" | \"DeclareVariable\" | \"ExistentialTypeParam\" | \"FunctionTypeAnnotation\" | \"FunctionTypeParam\" | \"GenericTypeAnnotation\" | \"InterfaceExtends\" | \"InterfaceDeclaration\" | \"IntersectionTypeAnnotation\" | \"MixedTypeAnnotation\" | \"NullableTypeAnnotation\" | \"NumericLiteralTypeAnnotation\" | \"NumberTypeAnnotation\" | \"StringLiteralTypeAnnotation\" | \"StringTypeAnnotation\" | \"ThisTypeAnnotation\" | \"TupleTypeAnnotation\" | \"TypeofTypeAnnotation\" | \"TypeAlias\" | \"TypeAnnotation\" | \"TypeCastExpression\" | \"TypeParameterDeclaration\" | \"TypeParameterInstantiation\" | \"ObjectTypeAnnotation\" | \"ObjectTypeCallProperty\" | \"ObjectTypeIndexer\" | \"ObjectTypeProperty\" | \"QualifiedTypeIdentifier\" | \"UnionTypeAnnotation\" | \"VoidTypeAnnotation\" | \"JSXAttribute\" | \"JSXClosingElement\" | \"JSXElement\" | \"JSXEmptyExpression\" | \"JSXExpressionContainer\" | \"JSXIdentifier\" | \"JSXMemberExpression\" | \"JSXNamespacedName\" | \"JSXOpeningElement\" | \"JSXSpreadAttribute\" | \"JSXText\" | \"Noop\" | \"ParenthesizedExpression\" | \"AwaitExpression\" | \"BindExpression\" | \"Decorator\" | \"DoExpression\" | \"ExportDefaultSpecifier\" | \"ExportNamespaceSpecifier\" | \"RestProperty\" | \"SpreadProperty\" | \"TSAnyKeyword\" | \"TSArrayType\" | \"TSAsExpression\" | \"TSBooleanKeyword\" | \"TSCallSignatureDeclaration\" | \"TSConstructSignatureDeclaration\" | \"TSConstructorType\" | \"TSDeclareFunction\" | \"TSDeclareMethod\" | \"TSEnumDeclaration\" | \"TSEnumMember\" | \"TSExportAssignment\" | \"TSExpressionWithTypeArguments\" | \"TSExternalModuleReference\" | \"TSFunctionType\" | \"TSImportEqualsDeclaration\" | \"TSIndexSignature\" | \"TSIndexedAccessType\" | \"TSInterfaceBody\" | \"TSInterfaceDeclaration\" | \"TSIntersectionType\" | \"TSLiteralType\" | \"TSMappedType\" | \"TSMethodSignature\" | \"TSModuleBlock\" | \"TSModuleDeclaration\" | \"TSNamespaceExportDeclaration\" | \"TSNeverKeyword\" | \"TSNonNullExpression\" | \"TSNullKeyword\" | \"TSNumberKeyword\" | \"TSObjectKeyword\" | \"TSParameterProperty\" | \"TSParenthesizedType\" | \"TSPropertySignature\" | \"TSQualifiedName\" | \"TSStringKeyword\" | \"TSSymbolKeyword\" | \"TSThisType\" | \"TSTupleType\" | \"TSTypeAliasDeclaration\" | \"TSTypeAnnotation\" | \"TSTypeAssertion\" | \"TSTypeLiteral\" | \"TSTypeOperator\" | \"TSTypeParameter\" | \"TSTypeParameterDeclaration\" | \"TSTypeParameterInstantiation\" | \"TSTypePredicate\" | \"TSTypeQuery\" | \"TSTypeReference\" | \"TSUndefinedKeyword\" | \"TSUnionType\" | \"TSVoidKeyword\"; 其中包括JSX、typescript 的AST类型，基本上根据类型名称都能了解其表示的含义，AST树就是由这些类型及其特定的属性组成的一个层级结构。介绍到这边，你应该联想到 Babel，联想到 js 混淆，联想到更多背后的东西。接下来，我们要介绍介绍 Babel 是如何将 ES6 转成 ES5 的。 BabelBabel本质上是一个编译器，他是将很多超前的，未在W3C规范中的语法编译转换成复合W3C规范的，旧代码执行器支持的代码。其具体内容本文不作介绍，如需了解请查看Babel。由于Es6、ES7、ES8、ES9等兼容性问题，在旧版本的代码执行器（浏览器环境）下，无法正确识别并执行，因此我们前端开发通常在build时使用babel将其转换成ES5的代码，确保低版本兼容性。下面我们来看看Babel是如何工作的。箭头函数转成function： 1let sum = (a, b)=&gt;&#123;return a+b&#125;; JSON格式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&#123; &quot;type&quot;: &quot;Program&quot;, &quot;start&quot;: 0, &quot;end&quot;: 31, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclaration&quot;, &quot;start&quot;: 0, &quot;end&quot;: 31, &quot;declarations&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclarator&quot;, &quot;start&quot;: 4, &quot;end&quot;: 30, &quot;id&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 4, &quot;end&quot;: 7, &quot;name&quot;: &quot;sum&quot; &#125;, &quot;init&quot;: &#123; &quot;type&quot;: &quot;ArrowFunctionExpression&quot;, &quot;start&quot;: 10, &quot;end&quot;: 30, &quot;id&quot;: null, &quot;expression&quot;: false, &quot;generator&quot;: false, &quot;async&quot;: false, &quot;params&quot;: [ &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 11, &quot;end&quot;: 12, &quot;name&quot;: &quot;a&quot; &#125;, &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 14, &quot;end&quot;: 15, &quot;name&quot;: &quot;b&quot; &#125; ], &quot;body&quot;: &#123; &quot;type&quot;: &quot;BlockStatement&quot;, &quot;start&quot;: 18, &quot;end&quot;: 30, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;ReturnStatement&quot;, &quot;start&quot;: 19, &quot;end&quot;: 29, &quot;argument&quot;: &#123; &quot;type&quot;: &quot;BinaryExpression&quot;, &quot;start&quot;: 26, &quot;end&quot;: 29, &quot;left&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 26, &quot;end&quot;: 27, &quot;name&quot;: &quot;a&quot; &#125;, &quot;operator&quot;: &quot;+&quot;, &quot;right&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 28, &quot;end&quot;: 29, &quot;name&quot;: &quot;b&quot; &#125; &#125; &#125; ] &#125; &#125; &#125; ], &quot;kind&quot;: &quot;let&quot; &#125; ], &quot;sourceType&quot;: &quot;module&quot;&#125; 我们通过Babel模拟转换过程如下： 12345678910111213141516171819202122const babel = require('babel-core'); //babel核心解析库const t = require('babel-types'); //babel类型转化库let code = `let sum = (a, b)=&gt;&#123;return a+b&#125;`;let ArrowPlugins = &#123;//访问者模式visitor: &#123; //捕获匹配的API ArrowFunctionExpression(path) &#123; let &#123; node &#125; = path; let body = node.body; let params = node.params; let r = t.functionExpression(null, params, body, false, false); path.replaceWith(r); &#125; &#125;&#125;let d = babel.transform(code, &#123; plugins: [ ArrowPlugins ]&#125;)console.log(d.code); babel-core是Babel的核心库，babel-types是Babel的类型转换库，通常我们开发Babel插件时需要了解这两个库，此处不作详细介绍，通过运行上述代码，我们得到的结果是： 123let sum = function (a, b) &#123; return a + b;&#125;; 这里，我们完美的将箭头函数转换成了标准函数。但是这也仅仅是针对这一一种情况而言，箭头函数还支持简写，如果是简写那么，该插件就会报错，因为其body中的结构和之前不一样了，此时JSON格式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&#123; &quot;type&quot;: &quot;Program&quot;, &quot;start&quot;: 0, &quot;end&quot;: 21, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclaration&quot;, &quot;start&quot;: 0, &quot;end&quot;: 21, &quot;declarations&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclarator&quot;, &quot;start&quot;: 4, &quot;end&quot;: 21, &quot;id&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 4, &quot;end&quot;: 7, &quot;name&quot;: &quot;sum&quot; &#125;, &quot;init&quot;: &#123; &quot;type&quot;: &quot;ArrowFunctionExpression&quot;, &quot;start&quot;: 10, &quot;end&quot;: 21, &quot;id&quot;: null, &quot;expression&quot;: true, &quot;generator&quot;: false, &quot;async&quot;: false, &quot;params&quot;: [ &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 11, &quot;end&quot;: 12, &quot;name&quot;: &quot;a&quot; &#125;, &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 14, &quot;end&quot;: 15, &quot;name&quot;: &quot;b&quot; &#125; ], &quot;body&quot;: &#123; &quot;type&quot;: &quot;BinaryExpression&quot;, &quot;start&quot;: 18, &quot;end&quot;: 21, &quot;left&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 18, &quot;end&quot;: 19, &quot;name&quot;: &quot;a&quot; &#125;, &quot;operator&quot;: &quot;+&quot;, &quot;right&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 20, &quot;end&quot;: 21, &quot;name&quot;: &quot;b&quot; &#125; &#125; &#125; &#125; ], &quot;kind&quot;: &quot;let&quot; &#125; ], &quot;sourceType&quot;: &quot;module&quot;&#125; 很明显，body 类型变成 BinaryExpression 不再是 BlockStatement，所以需要做一些兼容修改： 1234567891011121314151617181920212223242526const babel = require('babel-core'); //babel核心解析库const t = require('babel-types'); //babel类型转化库let code = `let sum = (a, b)=&gt; a+b`;let ArrowPlugins = &#123;//访问者模式 visitor: &#123; //捕获匹配的API ArrowFunctionExpression(path) &#123; let &#123; node &#125; = path; let params = node.params; let body = node.body; if(!t.isBlockStatement(body))&#123; let returnStatement = t.returnStatement(body); body = t.blockStatement([returnStatement]); &#125; let r = t.functionExpression(null, params, body, false, false); path.replaceWith(r); &#125; &#125;&#125;let d = babel.transform(code, &#123; plugins: [ ArrowPlugins ]&#125;)console.log(d.code); 最终输出结果： 123let sum = function (a, b) &#123; return a + b;&#125;; 到这边，看起来这个插件已经完美了，但是真实的babel-plugin-transform-arrow-function并不是这么简单，它内部还涉及到this指向的问题，此处不作详细讲解。 上文我们简单演示了 Babel 是如何来编译代码的，但是并非简单如此。Babel 使用一个基于 ESTree 并修改过的 AST，其使用的是开源的babylon解析库，目前改名为babel-parser。正如我们上面示例代码一样，Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）。 解析（parse）：解析步骤接收代码并输出处理后的 AST。 这个步骤分为两个阶段：词法分析 Lexical Analysis 和语法分析Syntactic Analysis。 词法分析：词法分析阶段把字符串形式的代码转换为令牌（tokens） 流。你可以把令牌看作是一个扁平的语法片段数组：1n * n; 例如上面的代码片段，解析结果如下：123456[ &#123; type: &#123; ... &#125;, value: \"n\", start: 0, end: 1, loc: &#123; ... &#125; &#125;, &#123; type: &#123; ... &#125;, value: \"*\", start: 2, end: 3, loc: &#123; ... &#125; &#125;, &#123; type: &#123; ... &#125;, value: \"n\", start: 4, end: 5, loc: &#123; ... &#125; &#125;, ...] 每一个 type 有一组属性来描述该令牌，和 AST 节点一样它们也有 start，end，loc 属性：12345678910111213141516&#123; type: &#123; label: &apos;name&apos;, keyword: undefined, beforeExpr: false, startsExpr: true, rightAssociative: false, isLoop: false, isAssign: false, prefix: false, postfix: false, binop: null, updateContext: null &#125;, ...&#125; 语法分析：语法分析阶段会把一个令牌流转换成 AST 的形式。 这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。 转换（transform）：接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。 这是 Babel 或是其他编译器中最复杂的过程，同时也是插件将要介入工作的部分。 生成（generate）：代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）。代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。 了解这这些过程，其实会发现我们上面实现的箭头函数转换插件变得很简单。 遍历AST的处理和转换需要使用到树形的遍历，树形遍历算法通常有前序、中序、后序、广度优先、深度优先，关于树遍历的算法本文不作详解，有兴趣的可以查阅资料或者转到Tree Structure中了解。我们发现上述使用了很多关于树操作的API，这些API并不是AST本身自带的API，而是每个parser赋予它的，AST本质上是一个树形数据结构，也可以看做是一个JSON，具体的每个parser的API我们后面介绍相关插件开发的时候再做补充说明。 扩展（具体语法树）AST被称为抽象语法树，看到这个名词的时候我们很可能会想，那对应的具体语法树呢？对的，具体语法树是存在的，具体语法树通常被称作分析树。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦AST 被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。","tags":"ast babel"},{"title":"cacheStorage","url":"/f688fea9/","text":"前言h5中本地存储除了LocalStorage、SessionStorage外还有一个鲜为人知的CacheStorage，顾名思义，其就是用来做缓存的storage，虽然通常很多东西都用localStorage和sessionStorage去进行存储，但用作缓存的话还是cacheStorage最佳。 介绍CacheStorage是浏览器提供的用作缓存存储的一个API类，通常配合service worker使用，但独立在主进程中使用也是可以的，其提供的丰富的api进行缓存的设置，清除，下载操作。当然，新的API都有其兼容性问题，详细兼容性可以查看。 API open(cacheName:string):Promise：打开或创建某个缓存区，是其他方法的执行前提。 add(path:string)：下载某个资源并缓存，通常用来做预缓存 addAll(paths:Array&lt;string&gt;)：批量下载资源并缓存，通常用来做预缓存 delete(key:string)：删除某个缓存 match(requestInfo:request|string)：查找、命中缓存 put(requestInfo:request|string，response: Response)：添加缓存 Examples 预缓存1234567window.caches.open(\"cache_name\").then(cache=&gt;&#123; // 预缓存 cache.addAll([ \"/a.css\" ]); cache.add(\"/b.css\");&#125;); 命中123window.caches.open(\"cache_name\").then(cache=&gt;&#123; return cache.match(\"/a.css\");&#125;); 删除123window.caches.open(\"cache_name\").then(cache=&gt;&#123; cache.delete(\"/a.css\");&#125;); 添加123window.caches.open(\"cache_name\").then(cache=&gt;&#123; cache.put(\"/a.css\",new Response());&#125;);","tags":"h5 cache storage cachestorage"},{"title":"workbox","url":"/d5dcded1/","text":"前言workbox 是 GoogleChrome 团队推出的一套 Web App 静态资源和请求结果的本地存储的解决方案，该解决方案包含一些 Js 库和构建工具，在 Chrome Submit 2017 上首次隆重面世。而在 workbox 背后则是 Service Worker 和 Cache API 等技术和标准在驱动。在 Workebox 之前，GoogleChrome 团队较早时间推出过 sw-precache 和 sw-toolbox 库，但是在 GoogleChrome 工程师们看来，workbox 才是真正能方便统一的处理离线能力的更完美的方案，所以停止了对 sw-precache 和 sw-toolbox 的维护。那workbox能解决什么问题呢？在service worker中，如果我们要拦截并代理所有的请求，需要我们手动去维护一套缓存列表。但是现在前端开发，多数用webpack、gulp、grant来构建前端的代码，导致我们的文件名可能会经常发生，这个时候，特别是中大型的多页应用，缓存列表的内容可能会非常多，手动维护就显得非常麻烦，维护成本也变得很高。这个时候，workbox的横空出世，就是为了解决上面的问题。 特性 不管你的站点是哪种方式构建的，都可以实现离线缓存的效果； 自动管理好缓存列表，包括更新、同步、删除旧的缓存等； 配置简单却不失灵活，可以完全自定义相关需求（支持 Service Worker 相关的特性如 Web Push, Background sync 等）。 针对各种应用场景的多种缓存策略。 使用 Register 123456789101112if ('serviceWorker' in navigator) &#123; window.addEventListener('load', function() &#123; navigator.serviceWorker.register(`./build.sw.js`) .then(function(registration) &#123; // Registration was successful console.log('[success] register ') &#125;, function(err) &#123; // registration failed :( console.log('[fail]: ', err); &#125;); &#125;);&#125; 注册代码与最终生成的sw.js文件名有关，也可查看了解更多，通常在webpack、gulp、grant相关插件中注册代码会自动生成。 Sw 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 首先引入 Workbox 框架importScripts('https://storage.googleapis.com/workbox-cdn/releases/3.3.0/workbox-sw.js');// Control all opened tabs ASAPworkbox.clientsClaim();// workbox.core.clientsClaim(); // workbox@4.0+workbox.skipWaiting();// workbox.core.skipWaiting(); // workbox@4.0+// 注册成功后要立即缓存的资源列表workbox.precaching.precacheAndRoute([ &#123; \"url\": \"css/index.css\", \"revision\": \"835ba5c3\" &#125;, &#123; \"url\": \"images/xxx.png\", \"revision\": \"b1537bfs\" &#125;, &#123; \"url\": \"index.html\", \"revision\": \"b331f695\" &#125;, &#123; \"url\": \"js/index.js\", \"revision\": \"4d562866\" &#125;]);// 缓存策略workbox.routing.registerRoute( new RegExp(''.*\\.html'), workbox.strategies.networkFirst());workbox.routing.registerRoute( new RegExp('.*\\.(?:js|css)'), workbox.strategies.cacheFirst());workbox.routing.registerRoute( new RegExp('https://your\\.cdn\\.com/'), workbox.strategies.staleWhileRevalidate());workbox.routing.registerRoute( new RegExp('https://your\\.img\\.cdn\\.com/'), workbox.strategies.cacheFirst(&#123; cacheName: 'example:img' &#125;)); 首先引入workbox框架，可以相对路径引用本地资源，也可以引用服务器资源，可以将其缓存，但是sw.js千万不能缓存。 通常第二步调用clientsClaim获取所有客户端管理权限，workbox@4.0+以后该方法被放到了workbox.core中 第三步调用skipWaiting使新的sw立即生效，该API按照需要进行调用 第四步使用precacheAndRoute预缓存一些资源，预缓存列表通常是由webpack、gulp、grant插件生成，因为其revision和文件版本相关，甚至每次编译文件名会发生改变。 第五步使用registerRoute配置runtime缓存 API setConfig 1234workbox.setConfig(&#123; debug:true,// 是否可调试 modulePathPrefix:\"/workbox-v3.6.3\",// 重写workbox库位置，用于本地库&#125;) setCacheNameDetails 123456workbox.core.setCacheNameDetails(&#123; \"prefix\": \"app\", // 缓存表名前缀 \"suffix\": \"v1\",// 缓存表后缀，通常用来指定版本号 \"precache\": \"precache\",// 预缓存表名 \"runtime\": \"runtime\"// runtime缓存表名&#125;) cleanupOutdatedCaches：清除过期的预缓存，根据revision及文件名进行清除，不满足条件的全部清除 1workbox.precaching.cleanupOutdatedCaches() registerNavigationRoute(cachedAssetUrl, options:{cacheName:string;blacklist:RegExp[];whitelist:RegExp[]})：注册导航请求路由，会返回预缓存文件，常用于App Shell中 1workbox.routing.registerNavigationRoute('/index.html'); registerRoute(capture:string|RegExp|Function, handler, method)：轻松注册string、RegExp、func路由 1workbox.routing.registerRoute(/\\/api\\//, workbox.strategies.networkFirst()); setCatchHandler(handler:(response:Promise)=&gt;void)：路由抛错回调函数 setDefaultHandler(handler)：定义没有路由匹配时，默认处理程序，默认无匹配则直接请求网络，跟无sw一样 unregisterRoute(route)：销毁路由，一般不会使用到 缓存策略缓存策略是指对于匹配到的路由，采取何种方式进行缓存。 workbox提供了两种配置缓存策略的方式 通过 workbox.strategies API 提供的 缓存策略。 提供一个自定义返回带有返回结果的 Promise 的回调方法。 以下介绍workbox默认提供的几种缓存策略，包含有五种，分别是： Stale While Revalidate Network First Cache First Network Only Cache Only Stale While Revalidate这种策略的意思是当请求的路由有对应的 Cache 缓存结果就直接返回，在返回 Cache 缓存结果的同时会在后台发起网络请求拿到请求结果并更新 Cache 缓存，如果本来就没有 Cache 缓存的话，直接就发起网络请求并返回结果。 使用方式如下： 1234workbox.routing.registerRoute( match, // 匹配的路由 workbox.strategies.staleWhileRevalidate()); 注意：对于没有使用precache预缓存的资源，会直接发起网络请求并返回结果，与上面强调的一句规则匹配。因此staleWhileRevalidate存在一定的问题，它在请求后不会将其缓存到Cache中，一定程度上===Network Only Network First：具体实现方式可以参考这种策略就是当请求路由是被匹配的，就采用网络优先的策略，也就是优先尝试拿到网络请求的返回结果，如果拿到网络请求的结果，就将结果返回给客户端并且写入 Cache 缓存，如果网络请求失败，那最后被缓存的 Cache 缓存结果就会被返回到客户端 使用方式如下： 1234workbox.routing.registerRoute( match, // 匹配的路由 workbox.strategies.networkFirst()); Cache First这个策略的意思就是当匹配到请求之后直接从 Cache 缓存中取得结果，如果 缓存中没有结果，那就会发起网络请求，拿到网络请求结果并将结果更新至 Cache 缓存，并将结果返回给客户端。 1234workbox.routing.registerRoute( match, // 匹配的路由 workbox.strategies.cacheFirst()); Network Only比较直接的策略，直接强制使用正常的网络请求，并将结果返回给客户端，这种策略比较适合对实时性要求非常高的请求。 1234workbox.routing.registerRoute( match, // 匹配的路由 workbox.strategies.networkOnly()); Cache Only [danger]这个策略也比较直接，直接使用 Cache 缓存的结果，并将结果返回给客户端，这种策略比较适合一上线就不会变的静态资源请求。 1234workbox.routing.registerRoute( match, // 匹配的路由 workbox.strategies.cacheOnly()); 注意：workbox@4.0+ 以后workbox.strategies中现有实例已废弃，需要使用new创建对应的实例，如：new workbox.strategies.StaleWhileRevalidate()、new workbox.strategies.NetworkFirst()、new workbox.strategies.CacheFirst()、new workbox.strategies.NetworkOnly()、new workbox.strategies.CacheOnly()workbox默认只针对GET请求，POST请求当作需要往服务端发送数据，自动放过对于cdn中资源，google官网建议使用Stale While Revalidate策略，但是使用下来发现该策略没有缓存效果，因为最初本地根本没有其缓存，因此以后每次都会向服务端请求，不起任何作用corss-origin 跨域资源无法直接使用Cache First策略，使用后不起作用cdn图片，跨域资源可以在Cache First的基础上集成插件cacheableResponse使用，此时就可以进行Cache First 策略缓存 1234567workbox.routing.registerRoute(new RegExp('^http://ec2-3-229-226-125.compute-1.amazonaws.com'), new workbox.strategies.CacheFirst (&#123; plugins: [ new workbox.cacheableResponse.Plugin(&#123; statuses: [0, 200, 404], // One or more status codes that a Response can have and be considered cacheable. &#125;), ]&#125;), 'GET') 效果使用domContentLoaded做为时间参考点，对比有无service worker的情况：以首页为例，在不同的网络环境下，发起10次网络请求，然后取平均值，作为它们的最终结果，测试结果如下： 网络环境 白屏时间（Service worker）/ms 白屏时间（正常请求）/ms 提升比例 wifi 310.8 358.8 14% 4G 311.2 875.2 181% 3G 313.8 2320 641% 2G 312.8 4752 1423% 离线 320 - 通过上面的数据可以得出几个结论: 在弱环境下，service worker的优势越发明显， 即使在wifi环境下面，由于存在缓存的情况，浏览器加载的速度也比未使用service worker的时间要短。 在无网络环境的情况，也可以做到离线缓存的效果，极大地提升页面的用户体验。 移动端兼容性测试有些文档显示移动端webview中已经支持，有些文档显示不支持，经过测试，发现默认情况下不支持，是否需要相关配置这方面资料不足，部分移动端浏览器中已经支持，需要后期研究相关设置。","tags":"h5 service-worker"},{"title":"service worker","url":"/bb551a96/","text":"前言随着前端可处理业务的复杂，页面中资源也越来越庞大，优化逐渐成为一个重要的关注点，而缓存在所有优化中占据重要的地位，本文主要介绍web缓存机制中的Service Worker。 基本介绍H5标准中对于前端资源缓存也提出了相应的方案，早起的application cache原本是W3C做为前端缓存主推的方案，但是随着该方案缺陷越来越明显，目前该方案已经被废弃，而最新的替代方案为service worker。Service worker是基于浏览器底层重新创建了一个单独的线程，独立于Web页面，做为一个脚本在浏览器Background默默运行，提供了丰富的离线体验，定期后台同步以及推送通知等功能。本文主要介绍Service Worker的常用功能，其新增功能可以访问Service Worker 扩展阅读。 特性 独立线程，不可以直接操作页面DOM，可以和页面进行通信，由页面去更新DOM 网络代理，做为一个可编程的网络代理，允许你控制当前网页网络请求如何发出，有过Android Webview开发经验的童鞋应该很容易理解，跟shouldInterceptRequest的功能类似 闲时等待，用时重启，在不使用时会停止运行，需要时重启，不会一直占用资源，没有一个全局的状态标志 支持数据库，支持IndexDB的访问 Promise语法，会用到大量的Promise语法，要求熟练掌握Promise 生命周期 使用 兼容性判断123if ('serviceWorker' in navigator) &#123; // TODO register&#125; 注册：register(scriptURL: string, options?: {scope?:string;type?:&quot;classic&quot; | &quot;module&quot;;updateViaCache?:&quot;imports&quot; | &quot;all&quot; | &quot;none&quot;})1234567window.addEventListener('load', function() &#123; navigator.serviceWorker.register('/sw.js').then(function(registration) &#123; console.log('ServiceWorker registration successful with scope: ', registration.scope); &#125;, function(err) &#123; console.log('ServiceWorker registration failed: ', err); &#125;);&#125;); 注意：页面在首次打开的时候就调用`register`进行缓存sw的资源，因为sw内预缓存资源是需要下载的，sw线程一旦在首次打开时下载资源，将会占用主线程的带宽，以及加剧对cpu和内存的使用，而且sw启动之前，它必须先向浏览器 UI 线程申请分派一个线程，再回到 IO 线程继续执行sw线程的启动流程，并且在随后多次在ui线程和io线程之间切换，所以在启动过程中会存在一定的性能开销，在手机端尤其严重；这将导致首屏性能更差，因此正确的做法是在页面加载完成后进行注册，即监听`load`事件中注册。 通过register API进行注册，支持注册选项配置： scope：配置该sw接管那个path下的请求，默认接管sw文件所在目录那一层，如果sw放在项目子文件夹中，需要通过scope:&quot;/&quot;，将其指定接管根目录下所有请求； updateViaCache：大部分浏览器（包括 Chrome 68 和更高版本）在检查已注册的sw脚本的更新时，默认情况下都会忽略缓存标头。在通过 importScripts() 提取sw内加载的资源时，它们仍会遵循缓存标头。可以在注册sw时，通过设置updateViaCache选项来替换此默认行为； type：目前理解为标识是传统的sw还是模块化的sw，目前未发现其作用，可能是后续扩展属性，等查到相关资料后补充。 注销：unregister()如果发生问题，怎么注销该sw并清除缓存，这都是要在注册时考虑的：1234567891011121314151617181920212223242526window.addEventListener('load', function() &#123; const sw = window.navigator.serviceWorker; const killSW = window.killSW || false;// 该标识应该是sw出现异常被kill后浏览器中接收到的状态 if (!sw) &#123; return &#125; if (!!killSW) &#123; // 注销代码 sw.getRegistration('/serviceWorker').then(registration =&gt; &#123; // 手动注销 registration.unregister(); // 清除缓存 window.caches &amp;&amp; caches.keys &amp;&amp; caches.keys().then(function(keys) &#123; keys.forEach(function(key) &#123; caches.delete(key); &#125;); &#125;); &#125;) &#125; else &#123; sw.register('/serviceWorker.js',&#123;scope: '/'&#125;).then(registration =&gt; &#123; console.log('Registered events at scope: ', registration.scope); &#125;).catch(err =&gt; &#123; console.error(err) &#125;) &#125; &#125;); 安装123456789self.addEventListener('install', function(event) &#123; event.waitUntil(caches.open(CACHE_NAME).then(function(cache) &#123; return cache.addAll([ '/', \"index.html\", \"main.css\", ]); &#125;));&#125;) 在安装中需要处理一些初始化，例如preCache，IndexDB 初始化等，preCache会直接下载并缓存指定文件，占用网络资源，因此不建议register直接在首屏加载时调用。 cacheStorage api：阅读cacheStorage waitUntil：函数内所有的promise,只要有一个promise的结果是reject，那么这次安装就会失败。比如说cache.addAll 时，有一个资源下载不回来，即视为整个安装失败，那么后面的操作都不会执行，只能等待sw下一次重新注册。另外waitUntil还有一个重要的特性，那就是延长事件生命周期的时间，由于浏览器会随时睡眠 sw，所以为了防止执行中断就需要使用 event.waitUntil 进行捕获，当所有加载都成功时，那么 sw 就可以下一步。 skipWaiting:安装成功后并不是立即被使用，如果当前页面已经存在sw进程，那么需要等待下一次页面被打开时新的sw才会被激活，或者使用self.skipWaiting()跳过等待，直接进入activate状态。 激活123456789101112self.addEventListener('activate', event =&gt; &#123; event.waitUntil(caches.keys().then(cacheNames =&gt; &#123; return cacheNames.filter(cacheName =&gt; CACHE_NAME !== cacheName); &#125;).then(cachesToDelete =&gt; &#123; return Promise.all(cachesToDelete.map(cacheToDelete =&gt; &#123; return caches.delete(cacheToDelete); &#125;)); &#125;).then(() =&gt; &#123; // 立即接管所有页面 self.clients.claim() &#125;));&#125;); 在activate中通常我们要检查并删除旧缓存，例如当sw发生变化或者CACHE_NAME发生变化则需要清除原有缓存，虽然说缓存区空间足够大，但是无用的缓存存在会影响命中效率clients.claim()： 接管所有页面，默认情况下，页面的请求（fetch）不会通过 sw，除非它本身是通过 sw 获取的，也就是说，在安装 sw 之后，需要刷新页面才能有效果，clients.claim可以强制接管，在激活后接管所有客户端。并非必须，因为仅第一次加载不经过sw，刷新后会经过sw，有时加上会出现一些问题，例如，加载和正常的请求不同资源时，也就是当作资源代理使用时会出现不可控问题，可能不经过sw直接从服务器请求。 请求拦截12345678910111213self.addEventListener('fetch', function(event) &#123; event.respondWith(caches.match(event.request).then(function(resp) &#123; const &#123;body,cache,credentials,headers,integrity,keepalive,method,mode,redirect,referrer,referrerPolicy,signal,window&#125; = event.request.clone(); return resp || fetch(event.request,&#123; body,cache,credentials,headers,integrity,keepalive,method,mode,redirect,referrer,referrerPolicy,signal,window &#125;).then(function(response) &#123; return caches.open(CACHE_NAME).then(function(cache) &#123; cache.put(event.request, response.clone()); return response; &#125;); &#125;); &#125;));&#125;); 通过监听fetch事件进行拦截请求，通常在内部需要判断哪些请求需要被处理，未使用event.respondWith处理的请求会直接采用原有方式发送到服务端。 event.respondWith：代理原有请求，将结果返回给初始请求 先判断缓存中是否存在，如果命中直接返回缓存的response，否则再发送fetch请求，发送成功后先存入缓存，然后再返回给主进程 此处需要注意如果要发送的请求，需要cookie或者跨域，即原有请求设置了credential和mode参数，则sw中也fetch也需要设置，即需要将request中的对应参数进行复用 请求流和响应流只能被读取一次，因此response需要使用response.clone进行复制 请求策略目前根据service worker衍生出的请求策略包括以下几种： networkFirst：首先尝试通过网络来处理请求，如果成功就将响应存储在缓存中，否则返回缓存中的资源来回应请求。它适用于以下类型的API请求，即你总是希望返回的数据是最新的，但是如果无法获取最新数据，则返回一个可用的旧数据。具体实现如下：12345678910111213function networkFirst(request)&#123; return fetch(request).then(response=&gt;&#123; const clone = response.clone(); caches.open(CACHE_NAME).then(cache=&gt;&#123; cache.put(request,clone); &#125;) &#125;).catch(()=&gt;&#123; return caches.op(CACHE_NAME).then(cache=&gt;cache.match(request)); &#125;)&#125;self.addEventListener('fetch', function(event) &#123; event.respondWith(networkFirst(event.request));&#125;); cacheFirst：如果缓存中存在与网络请求相匹配的资源，则返回相应资源，否则尝试从网络获取资源。 同时，如果网络请求成功则更新缓存。此选项适用于那些不常发生变化的资源，或者有其它更新机制的资源。具体实现如下：12345678910111213function cacheFirst(request)&#123; return caches.open(CACHE_NAME).then(cache=&gt;cache.match(request)).then(response=&gt;&#123; return response||fetch(request).then(function(res) &#123; return caches.open(CACHE_NAME).then(function(cache) &#123; cache.put(request, res.clone()); return response; &#125;) &#125;); &#125;)&#125;self.addEventListener('fetch', function(event) &#123; event.respondWith(cacheFirst(event.request));&#125;); fastest：从缓存和网络并行请求资源，并以首先返回的数据作为响应，通常这意味着缓存版本则优先响应。一方面，这个策略总会产生网络请求，即使资源已经被缓存了。另一方面，当网络请求完成时，现有缓存将被更新，从而使得下次读取的缓存将是最新的。具体实现如下：12345678910111213141516171819202122function fastest(request)&#123; const TIMEOUT = 500; let timer; return Promise.race([new Promise((resolve,reject)=&gt;&#123; timer = setTimeout(()=&gt;&#123; caches.open(CACHE_NAME).then(cache=&gt;cache.match(request)).then(response=&gt;&#123; if(response)&#123; resolve(response); &#125; &#125;) &#125;,TIMEOUT) &#125;),fetch(request).then(function(res) &#123; clearTimeout(timer); caches.open(CACHE_NAME).then(function(cache) &#123; cache.put(request, res.clone()); &#125;); return res; &#125;)])&#125;self.addEventListener('fetch', function(event) &#123; event.respondWith(fastest(event.request));&#125;); cacheOnly：从缓存中解析请求，如果没有对应缓存则请求失败。此选项适用于需要保证不会发出网络请求的情况，例如在移动设备上节省电量。具体实现如下：123456function cacheOnly(request)&#123; return caches.open(CACHE_NAME).then(cache=&gt;cache.match(request));&#125;self.addEventListener('fetch', function(event) &#123; event.respondWith(cacheOnly(event.request));&#125;); networkOnly：尝试从网络获取网址来处理请求。如果获取资源失败，则请求失败，这基本上与不使用service worker的效果相同。具体实现如下：123456function networkOnly(request)&#123; return fetch(request);&#125;self.addEventListener('fetch', function(event) &#123; event.respondWith(networkOnly(event.request));&#125;); 通常静态资源采用缓存优先的方式进行加载，api可以使用网络优先或者networkOnly，具体的优先策略根据项目需要进行调整。 更新 service worker 的更新虽然没有application cache 那样繁琐，但是也并不简单，如果处理不好仍然会存在一些问题，正常情况下建议service worker不去做改动。 默认情况下，service worker 浏览器至少每隔24小时去检查一次是否更新，刷新页面会立即去进行下载比较，当然不刷新页面也可以通过update方法进行更新操作：12345678window.addEventListener('load', function() &#123; navigator.serviceWorker.register('/sw.js').then(function(registration) &#123; // some time later ... registration.update(); &#125;, function(err) &#123; console.log('ServiceWorker registration failed: ', err); &#125;);&#125;); 浏览器下载sw脚本后会与原有脚本进行字节对比，如果发现不同则会进行安装新的sw，安装后默认情况下新的sw处于等待状态，原有的仍然处于运行状态，直到原有sw管理的所有窗口全部关闭时旧的sw才会停止，新的sw才会在接下来重新打开的页面里生效。 如果不想要新的sw进行等待，可以在install中调用skipWaiting去跳过等待状态。直接进入activate状态，并接管当前窗口，多窗口可以在activate中使用clients.claim()方法强制接管所有关联窗口。 除了强制接管外还有以下方案进行更新： controllerchange：主程序中通过该事件监测sw是否更新，如果更新则刷新页面，例如：123navigator.serviceWorker.addEventListener('controllerchange',()=&gt;&#123; window.location.reload();&#125;) 该方法在sw出现更新时会造成用户刚进入又自动刷新的现象，用户体验较差，不推荐使用。 同上，参考lavas库监测到更新后浏览器顶部弹出一个提示气泡，提示用户去刷新sw，例如：12345678910111213try &#123; navigator.serviceWorker.getRegistration().then(reg =&gt; &#123; reg.waiting.postMessage('skipWaiting'); &#125;);&#125; catch (e) &#123; window.location.reload();&#125;// sw.jsself.addEventListener('message', event =&gt; &#123; if (event.data === 'skipWaiting') &#123; self.skipWaiting(); &#125;&#125;) 兼容性目前service worker的兼容各大浏览器是从16年左右开始，也就是之前版本的浏览器都不兼容，因此兼容性相对于application cache来说比较差，移动端Android5+，IOS11.3+才兼容，具体兼容性可以查看。仅在https和localhost下生效，http站点中不支持。 注意点 sw.js 从项目开始到最终项目下线，不可以修改其文件名，如果修改文件名会出现无法更新的问题，因为通常页面是被缓存的，页面中注册的sw.js任然是以前的sw服务，甚至如果原有的sw文件不存在的情况下，注册会失败，任然使用原有服务。 不要给sw.js设置缓存，同样的问题，影响网站更新，sw.js设置了缓存后可能永远都不会更新sw.js 工程化如果在sw.js中不是通过泛类型的方式过滤资源的缓存的话，每次在项目打包时静态资源文件名会出现变化，其后面带的[hash]值会不一样，此时如果想要通过sw缓存固定的某个资源，需要根据编译的结果去进行配置，因此工程化建议使用泛类型或者webpack sw相关插件进行配置。 第三方工具 sw-precache：google 早期的轮子，与2006年停止维护，有对应的webpack插件 sw-toolbox：google 早期的轮子，与2006年停止维护，有对应的webpack插件 workbox：google最新推荐的工具，百度的[lavas](https://lavas.baidu.com/)底层使用的就是这个。 serviceWorker在线检测 support: document.getElementById(\"support\").innerText=navigator.serviceWorker!==void 0;iframe support:document.getElementById(\"support1\").innerText=document.getElementById(\"support_iframe\").contentWindow.navigator.serviceWorker!==void 0;","tags":"h5 cache optimize pwa service-worker to-supplement"},{"title":"application cache","url":"/58a73389/","text":"前言 随着H5的发展，前端业务也来越复杂，页面中资源逐渐庞大，优化逐渐成为一个重要的关注点，而缓存在所有优化中占据重要的地位，本文主要介绍web缓存机制中的Application Cache。 基本介绍 顾名思义，Application Cache就是应用缓存，首次访问时会对需要缓存的资源进行下载并且缓存到浏览器的缓存区，再次访问时会优先访问本地缓存，如果没有才会访问服务器，该方式在一定程度上较少了不必要的请求，但容易引起强缓存问题，目前该规范已被W3C废弃，纳入了不推荐使用行列，但是其兼容性目前看非常好。 使用方式 首先对于需要缓存的html创建对应的appcache文件，etc index.appcache12345678910CACHE MANIFEST# version xx.xx.xxCACHE:test.csshttp://img95.699pic.com/photo/50109/8980.jpg_wh860.jpgNETWORK:*FALLBACK: 其中具体格式如上，首先需要通过CACHE MANIFEST声明这是一个缓存配置文件，其次CACHE下定义哪些文件需要进行缓存，NETWORK中定义哪些文件不需要进行缓存，FALLBACK定义当资源无法访问时，浏览器会使用某个页面或资源 配置规则： 支持资源全路径，etc http://img95.699pic.com/photo/50109/8980.jpg_wh860.jpg 支持资源相对路径，etc test.css 支持通配符* 不支持局部通配符，如*.css html文件中引入：123&lt;html manifest=\"index.appcache\"&gt;&lt;/html&gt; 优点 配置简单 支持跨域缓存，可以缓存其他域名下的资源 支持通配符，可以对其他文件进行全部缓存或不缓存配置 体验 到这里，application cache 基本使用就已经结束了，打开网站会发现第一次访问时在浏览器请求资源的同时，application cache也再次请求需要被缓存的资源，并缓存到浏览器缓存区中。再次访问时页面资源完全从本地读取，Network中会发现资源的Size列显示（disk cache）： 资源无需从服务器下载，速度非常快，感觉非常美滋滋~ There are pits everywhere 如果到此处你以为就完了那你就真的完了，犹如标题一样，受更新机制影响，你会发现到处都是坑： 配置application cache的html文件必定会被缓存，以后当html发生改变时不会立即生效，甚至永远不会生效，如果只想缓存css、js、png等静态资源而不想缓存html，目前来说是个大坑 默认appcache文件也同时会被缓存，如果该文件也被缓存，那么除非手动清除浏览器中的缓存，否则不会更新 每个html都需要添加manifest属性 只要有文件缓存失败则整个缓存事务回滚，不会缓存任何文件 根据Application Cache的加载机制，如果仅仅修改资源文件的内容（没有修改资源文件的路径或名称），浏览器将直接从本地离线缓存中获取资源文件。所以在每次修改资源文件的同时，需要修改manifest文件，以触发资源文件的重新加载和缓存。这其中，最有效的方式是修改manifest文件内部的版本注释（所以说那句注释相当重要） 如果资源没有被缓存，在而没有设置NETWORK的情况下，将会无法加载（浏览器不会去网络上进行加载），所以需要使用通配符来表明除了CACHE中确定的资源以外，其他资源都需要去网络上加载 当浏览器检测到资源发生更新（如manifest文件更新或者文件名发生改变）时并不会立即使用服务器中的资源，而是从缓存中读取，同时application cache从服务器获取新的资源并缓存，默认情况下下次访问时才会使用新的缓存。 首次访问，两次请求资源，加大了首次访问的负担 更新机制 在解析html DOM树时，如果检查到html节点配置了manifest属性，会先下载对应的appcache文件 解析manifest文件并根据规则将页面中用到的资源和appcache中配置的需要缓存的资源重新从服务器获取，并缓存到缓存区 当manifest发生更新或者资源名或路径发生改变时，进入页面后会重新从服务端获取新的资源并缓存，但当前应用的仍然是缓存中的资源 缓存更新后下次进入则会从缓存区获取最新的资源并应用 Filling pits appcache文件自身必须要配置到NETWORK中，防止客户端将其缓存后服务器端更新失效 有人提出通过iframe进行缓存，防止当前html被缓存，即manifest属性设置到iframe对应的html中，仅缓存iframe的页面而不缓存主页面，这样做你会发现缓存中真的没有该文件，但是刷新后css、js等资源并没有从缓存中读取，而是从服务器获取了。因此该方法并没有实际作用，缓存应该和主文件有关联，哪个主文件下缓存的资源仅在该主文件下有效。 通过application cache提供的API进行手动刷新缓存 123456789101112131415161718192021222324252627282930313233343536373839404142434445//手动更新 window.applicationCache.update();applicationCache.onchecking = function()&#123; //检查manifest文件是否存在&#125;applicationCache.ondownloading = function()&#123; //检查到有manifest或者manifest文件 //已更新就执行下载操作 //即使需要缓存的文件在请求时服务器已经返回过了&#125;applicationCache.onnoupdate = function(e)&#123; //返回304表示没有更新，通知浏览器直接使用本地文件 &#125;applicationCache.onprogress = function()&#123; //下载的时候周期性的触发，可以通过它 //获取已经下载的文件个数&#125;applicationCache.oncached = function()&#123; //下载结束后触发，表示缓存成功&#125;applicationCache.onupdateready = function()&#123; //第二次载入，如果manifest被更新 //在下载结束时候触发 //不触发onchched applicationCache.swapCache();// 得到最新版本缓存列表，并且成功下载资源，更新缓存到最新 location.reload();// 刷新页面&#125;//清单 5 手动更新缓存if (window.applicationCache.status == window.applicationCache.UPDATEREADY)&#123; window.applicationCache.update(); &#125;applicationCache.onobsolete = function()&#123; //未找到文件，返回404或者401时候触发&#125;applicationCache.onerror = function()&#123;&#125; 刷新后需要reload页面，用户体验极差。 Results 虽然该机制在浏览器中兼容性极好，包括低版本的浏览器和移动端webview都支持，但是已经被W3C废弃，后续版本肯定会移出，W3C官方也不建议使用，同时上述的pits也无法有效解决，解决不了更新问题，那带来的是更加严重的问题。","tags":"h5 cache optimize deprecated"},{"title":"package.json","url":"/14f889f2/","text":"概述 本文主要介绍package.json一系列配置文件中你所需要掌握的细节。注意package.json必须是一个完全的JSON，而不是Javascript对象字面量；该文件描述受npm-config中的配置影响，下面主要介绍每个字段的含义和用法。 字段 name name字段是必须字段，这个字段指定npm包的包名，如果不指定则无法被安装也无法发布，包名在一个仓库中必须唯一。 规则： 长度必须小于214字节 不能以.或_开头 不能包含大写字母和中文 不能有非URL安全的字符（特殊字符） 可以使用@scope来创建私有包，例如@yanxlg/rtl-tool version version字段是必须字段，这个字段指定当前包的版本，version和name组成包的唯一标识，version应与包内容是同步的。 规则： 组成：major.minor.patch-prerelease major：主版本号，通常有重大更新，如设计变动、模块重构等，与前一大版本不兼容时升级 minor：次版本号，通常表示一些大的版本更改，比如API变动时升级 patch：修补版本号，用于bug-fix或者优化时升级 prerelease：预发布版本号，可能存在一些问题，但是其他环境需要使用到该包的时候指定，表明非正式发布 description 包的描述，是一个字符串，对于npm仓库搜索引擎有效，可以方便开发者找到这个包 keywords keywords表明包的关键字，是一个字符串数组，对于npm仓库搜索引擎有效，可以方便开发者找到这个包 homepage 包的官网url，是一个合法uri地址 bugs 当遇到bugs反馈地址及邮箱，通常指定github的issues地址和开发者邮箱，例如： 1234&#123; \"url\": \"https://github.com/yanxlg/csdn/issues\", \"email\": \"project@hostname.com\"&#125; license 版权，需要指定一个license让使用者知道他们的使用权利和限制，默认是&quot;ISC&quot;，常用的有MIT、ISC、UNLICENSED、Apache-2.0等，可以查看SPDX许可证标识符的完整列表选择自己适合的许可证标识，推荐使用经过OSI核准的标识符，如果你的包在多个许可证下被授权，可以使用SPDX许可证表达式语法v2.0(OR、AND、WITH)，例如 1&#123; \"license\" : \"(ISC OR GPL-3.0)\" &#125; 如果使用的许可未被授予SPDX吧标识符，或者使用自定义许可证，可以使用在当前包目录下创建一个eg:LICENSE的文件，然后使用下列语法指定： 1&#123; \"license\" : \"SEE LICENSE IN LICENSE\" &#125; 如果不想让别人以任何方式使用该包，可以使用UNLICENSED标识符表明是私有包，对于其他人员不予授权 author、contributors author表示作者，包的拥有者；contributors表示贡献者、参与者；author可以是一个对象或字符串，contributors可以是对象数组或字符串，对象格式如下： 1&#123;\"author\": &#123;\"name\": \"xlyan\",\"email\": \"xlyan@email.com\",\"url\": \"xlyan@home.com\"&#125;&#125; 其中email和url可以省略，当只有一个对象时可以简写成字符串，以Space隔开，author可以直接写成： 1&#123;\"author\": \"xlyan xlyan@email.com xlyan@home.com\"&#125; files 指定哪些文件被包含在包中，可以指定具体文件或文件名，是一个字符串数组，该字段在publish时比较重要，限制了哪些文件会被添加到发布的package中，如果不进行配置则表示所有文件均包括在包中，当然还有另一种方法忽略项目文件，就是使用.npmignore配置文件，ignore文件优先级相对较高，如果其中忽略了某个文件，不管files中是否包含都会被忽略 mainmain指定模块的入口程序文件，是一个按照CommonJS规范生成的文件，通常指定为lib/index.js modulemodule指定模块入口程序文件，是通过ES Module格式生成的文件，在导入时使用的tree shaking等特性，从而提升了打包性能，优先级高于main，目前尚未被加入到规范中，但编译工具都已支持，通常指定为es/index.js，文件中使用ES6特性，未被babel转换 typings指定模块typescript声明文件，该方式是全局指定，也可以在每个js文件的同级目录创建一个d.ts文件，与js文件相关联 bin可执行文件命令名和文件映射表，在安装包时会将可执行文件添加软连接到系统中，如果是全局安装则会关联到prefix/bin中，如果是本地安装则会链接到./node_modules/.bin中。全局安装后可以在全局使用指定的命令，本地安装仅可在当前安装目录下使用，设置方式:1&#123;\"bin\": &#123;\"bin1\": \"./bin/bin1\",\"bin2\": \"./bin/bin2\"&#125;&#125; man指定一个单一的文件名或一个文件名数组来让man程序使用。通常指定一个文档数组，很少使用 directoriesCommonJS Packages规范说明了几种你可以用directories对象来标示你的包结构的方法。如果你去看npm’s package.json，你会看到它标示出出doc、lib和man。在未来，这个信息可能会被用到，暂时没有实际意义。 repository代码托管位置，对于想要源码的人很有帮助，通常指定type和url两个字段或者使用缩写，例如1&#123;\"repository\": &#123;\"type\": \"git\",\"url\": \"https://github.com/npm/npm.git\"&#125;&#125; scripts脚本命令，配置可运行的npm命令，在前端或node项目中非常有用，支持pre和post命令前后钩子，如：1&#123;\"scripts\": &#123;\"prestart\": \"./prefix.js\",\"start\": \"react-dev-tools start\",\"poststart\": \"./clear.js\"&#125;&#125; 优先执行pre命令在pre命令执行完成后执行指定的命令，执行完成后执行post命令，到此，你运行的命令才会结束 config一个配置对象，用来配置包脚本中跨版本参数，如指定port等包的配置参数，也可以使用npm config或yarn config命令配置，如：1npm config set foo:port 8001 这就是指定foo模块的config中port值为8001 dependencies指定依赖的包名和版本号列表，用于存放生产使用和非测试的包，在该包被安装时所有dependencies都会同步被安装，具体版本号写法可以参考下面版本说明 devDependencies如果需要使用到某个包，但是不需要使用其外部测试和文档，则将其放在devDependencies中比较合适，通常建议与dependencies的区分为，工具和测试类package放在devDependencies中，最终build需要的源码package放在dependencies中，仅供参考，不强制要求。 peerDependenciespeerDependencies是做为一个插件的功能被使用，意思是如果你安装我，那么你最好也安装X,Y和Z。其他依赖配置中的包都会被安装在当前包的node_modules下，而不是安装在项目根目录到额node_modules下，因此直接使用会存在问题：12345MyProject|- node_modules |- PackageA |- node_modules |- PackageB PackageA中未在peerDependencies中引用PackageB就会出现上面的目录结构，导致项目中无法直接使用PackageB，而如果使用peerDependencies则会变成：1234MyProject|- node_modules |- PackageA |- PackageB 此时在项目中可以直接使用PackageB bundledDependencies在发布包时，包名的数组会被打包进去。会添加到dependencies中 optionalDependencies如果一个依赖项可用，但希望在这个依赖项无法被找到或者安装失败时npm还能继续处理(不中断)，那么你可以把它放在optionalDependencies中。和dependencies一样，optionalDependencies是一个包名和版本号或url的映射。区别在于optionalDependencies中的依赖构建失败时不会导致npm整体安装失败 engines你可以指定node的工作版本： 1&#123; \"engines\" : &#123; \"node\" : \"&gt;=0.10.3 &lt;0.12\" &#125; &#125; 和dependencies类似，如果你不指定一个node版本(或者你用’*’指定)，则任何一个node版本都可以。如果你指定了一个’engines’字段，则npm将会在某处包含这个node版本。如果忽略’engines’字段，则npm只会仅仅假设这个包工作在node下。你还可以使用’engines’字段来指定可以安装这个包的npm版本，举个栗子：1&#123; \"engines\" : &#123; \"npm\" : \"~1.0.20\" &#125; &#125; 请注意，除非用户设置了engine-strict标记，否则这个字段只是一个建议值。 os指定模块运行的操作系统，是个字符串数组，可以使用darwin、win32、linux或者可以加!实现黑名单 cpu指定模块只能在特定的cpu架构上运行，如：1&#123;\"cpu\": [\"x64\", \"ia32\"]&#125; 当然，也可以使用!的方式实现黑名单 preferGlobal如果你的包是一个需要作为全局安装的命令行应用，则需要指定该属性，在拒不安装是会给与警告，但不会阻止用户拒不安装。 private第三种声明包为私有包的方式，是一个boolean值，true表示是私有包，false表示非私有 publishConfig发布配置项，在发布时如果npm publish后面需要加其他配置参数，可以将其配置在该项中，然后直接使用npm publish即可，通常用来配置access、tag、registry等 版本说明 dependencies中的包支持多种方式声明： npm 仓库方式：直接指定版本号，按照版本号格式进行配置 URLs 做为依赖项：指定一个压缩包的url，在install时会自动下载该压缩包并安装 Git URLs 做为依赖项：指定一个git仓库的地址为依赖路径，可选形式如下:12345git://github.com/user/project.git#commit-ishgit+ssh://user@hostname:project.git#commit-ishgit+ssh://user@hostname/project.git#commit-ishgit+http://user@hostname/project/blah.git#commit-ishgit+https://user@hostname/project/blah.git#commit-ish commit-ish可以是任何tag、sha或者branch，并作为一个参数提供给git进行checkout，默认值是master。 GitHub URLs 做为依赖项:从1.1.65版本开始，你可以引用Github urls作为版本号，比如”foo”: “user/foo-project”。也可以包含一个commit-ish后缀，举个栗子： 1234\"dependencies\": &#123; \"express\": \"visionmedia/express\", \"mocha\": \"visionmedia/mocha#4727d357ea\"&#125; 本地路径 做为依赖项：从版本2.0.0开始你可以提供一个包的本地路径。本地路径可以在你使用npm install -S或npm install –save时被保存，具体形式如下： 1234../foo/bar~/foo/bar./foo/bar/foo/bar 这个特性有助于当你不想从一个外部服务器安装npm包的情况，比如本地离线开发和创建测试，但最好不要在发布包到公共registry时这样使用。 版本格式 version 必须确切匹配这个version &gt;version 必须大于这个version &gt;=version 必须大于等于这个version &lt; version 必须小于这个version &lt;=version 必须小于等于这个version ~version 大约相当于version，参考semver，会优先升级patch版本号，但是不会升级minor版本号 ^version 与version兼容，参考semver，会升级minor版本号，但不会升级major版本号 1.2.x 可以是1.2.0、1.2.1等，但不能是1.3.0 * 匹配任何版本 “”(空字符串) 匹配任何版本，和*一样 version1 - version2 相当于 &gt;=version1 &lt;=version2 range1 || range2 range1或range2其中一个满足时采用该version tag 一个以tag发布的指定版本，参考npm-tag","tags":"h5 node package.json"},{"title":"Background Services","url":"/58a5f4e8/","text":"##前言 随着h5中service worker的出现，开发者已经可以实现一些数据缓存及简单的后台服务功能，但是早期的service worker在后台获取接口及延迟发送数据方面仍然不足，因此扩展了两个Background Services来实现这两个功能。 Background Fetch 解决问题： 当service worker在下载大文件到缓存中时，如果用户离开了，即使使用原来的event.waitUntil，这个service worker仍然可能会被杀死 当service worker在上传问件时，如果用户离开则上传文件会中断 作用： background Fetch允许开发者在当前上下文之外操作和控制文件列表，提高了上传和下载的成功率，同时可以让service worker缓存请求结果。 Example:1234567891011121314151617181920212223242526// 业务代码navigator.serviceWorker.register('/sw.js').then(function(reg) &#123; const button = document.getElementById('download'); if ('backgroundFetch' in reg) &#123; button.addEventListener('click', function(event) &#123; reg.backgroundFetch.fetch('large-file', [new Request('/images/twilio.png')], &#123; title: 'Downloading large image' &#125;).then(function(backgroundFetch) &#123; console.log(backgroundFetch) &#125;); &#125;) &#125;&#125;); // service workerself.addEventListener('backgroundfetched', function(event) &#123; event.waitUntil(caches.open('downloads').then(function(cache) &#123; event.updateUI('Large file downloaded'); registration.showNotification('File downloaded!'); const promises = event.fetches.map((&#123; request, response &#125;) =&gt; &#123; if (response &amp;&amp; response.ok) &#123; return cache.put(request, response.clone()); &#125; &#125;); return Promise.all(promises); &#125;) );&#125;); Background Sync 解决问题： 延迟发送请求，直到用户网络稳定 form 提交或者文件上传必须要等到提交完成，才能离开 作用： 可以在发送数据时使用调度，聊天，消息，邮件，文档更新，设置更改时，上传照片时，任何想要发送给服务器的数据都可以使用。即使页面关闭或用户跳转到其他页面，该页面也会将数据存到Indexed DB，并且Service Worker会检索到这些信息，并且发送。 Example：123456789navigator.serviceWorker.register('/sw.js');navigator.serviceWorker.ready.then(function(swRegistration) &#123; return swRegistration.sync.register('myFirstSync');&#125;);self.addEventListener('sync', function(event) &#123; if (event.tag == 'myFirstSync') &#123; event.waitUntil(doSomeStuff()); &#125;&#125;);","tags":"h5 background-services service-workers"},{"title":"共享sdk实例","url":"/5c4fa24d/","text":"","tags":""},{"title":"跨窗口通信","url":"/aefa6556/","text":"","tags":"h5 cross-window"},{"title":"submodule","url":"/6a58ae0d/","text":"前言 随着前端的发展，前端项目越来越庞大、臃肿，模块化的思想越来越普及，不同的项目公用的模块需要进行统一管理，由此提出来组件库的思想。 组件库构建方式 npm 仓库： 直接使用npm官方仓库，通过注册npm官方企业账号或个人账号，开发npm模块代码，并使用npm publish或者yarn publish 将模块发布到npm仓库，使用时直接在package.json的dependencies或者devDependencies中配置模块及版本，并且使用npm install、yarn add或者yarn isntall安装指定模块或所有模块 私有仓库： cnpm: 通过阿里开源的cnpm进行部署企业内网npm仓库，配置教程 Nexus：配置教程 npm + git：npm install 可以和git进行结合，支持从git仓库下载并安装模块，package.json中配置如下123\"dependencies\":&#123; \"moduleName\": \"git+ssh://git@ip/project.git#version\",&#125; etc … git submodule git 支持子模块配置功能，可以将git上其他项目添加到当前项目中做为子模块管理，常用命令为： script1234git submodule init # 初始化当前项目中的.gitmodules文件git submodule update # 更新当前项目.gitmodules配置文件中配置的子项目git submodule add &lt;submodule_url&gt; &lt;submodule_path&gt; # 向当前项目添加子项目，同时会更新或创建.gitmodules文件git clone --recurse-submodules &lt;main_project_url&gt; # clone主项目的同时下载所有子项目 通过git的submodule功能同样能够管理项目依赖，实现项目关系架构设计。总结以上方案没有明显的优缺点，根据需要进行取舍，常规企业会拥有自己的私有npm服务器，同时在项目依赖时也会用到git submodule","tags":"h5 node npm git submodule project-framework"},{"title":"cache","url":"/41476be7/","text":"application cache localStorage实现库缓存","tags":"h5 cache application-cache cache-store"},{"title":"storage","url":"/547a1b34/","text":"前言 随着前端业务的复杂化，前端对于数据敏感度越来越高，对于本地化存储数据的需求越来越多，本文主要介绍目前前端中可用于数据存储的方式 本地化方案 cookie cookie 作用 服务端通常使用cookie+session来进行验证、授权等权限控制操作。 cookie可以临时存储小量数据供客户端使用，例如加密秘钥等 客户端可以将部分数据同时cookie来实现长期存储，或者传递给服务端 cookie 大小：不超过4KB cookie 限制cookie 在传统web中起到非常重要的作用，因为传统web仅能通过cookie在本地存储一些数据，常用与进行账号验证，token下发，授权等。cookie存在很多限制问题，具体如下： 一、浏览器允许每个域名所包含的cookie数： &emsp;Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。&emsp;&emsp;Firefox每个域名cookie限制为50个。&emsp;&emsp;Opera每个域名cookie限制为30个。&emsp;&emsp;Safari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。&emsp;&emsp;注：“每个域名cookie限制为20个”将不再正确！二、当很多的cookie被设置，浏览器如何去响应。&emsp;&emsp;除Safari（可以设置全部cookie，不管数量多少），有两个方法：&emsp;&emsp;最少最近使用（leastrecentlyused(LRU)）的方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。&emsp;&emsp;Firefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。三、不同浏览器间cookie总大小也不同：&emsp;&emsp;Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。&emsp;&emsp;Opera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。&emsp;&emsp;Internet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。注：多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。 cookie 的属性 ①. HttpOnly：该属性限制cookie仅能在http请求中被使用，通过javascript无法读取，可以有效防止XSS攻击 ②. Secure：该属性限制仅在SSH链接时才会向服务端发送cookie，即尽有https协议中才会附带客户端cookie ③. Path：cookie生效路径，cookie仅在当前路径下可以被访问，该限制对javascript和http请求都生效，必须以/结束，是一个目录路径 ④. Domain：cookie生成域名，cookie尽在该域名下可以被访问，同时对javascript和http请求生效 ⑤. MaxAge：cookie失效时间，单位秒，如果是整数，则在maxAge之后失效，如果是负数表示是临时cookie，关闭浏览器即会失效，同时会清除，如果是0表示删除该cookie，默认是-1 ⑥. Name： cookie键名 ⑦. Value：cookie值 ⑧. Comment：cookie使用说明 ⑨. Version：cookie版本号 cookie 生命周期 cookie通常在http请求服务器时，服务器通过Set-Cookie设置到客户端中，客户端与服务端通信时，http请求中会自动带上服务端可以访问到的cookie，服务端通过cookie进行验证处理，当cookie失效时，浏览器并不会立即清除cookie,会在窗口关闭后清除 cookie 应用范围 仅存在于http协议中，其他TCP/IP 协议中是不存在的，虽然Websocket握手是基于Http协议的，仅可以在握手拦截器中获取到cookie去进行验证,通信过程中无法获取cookie cookie 客户端使用方式 读取：document.cookie，返回所有可以访问的cookie键值对字符串，以；连接 设置：document.cookie，通过document.cookie将需要设置的cookie进行属性覆盖 删除：通过document.cookie设置expire过期时间实现删除 sessionStorage sessionStorage与session是两个完全不同的概念，session是一个会话连接，通常配合cookie实现会话保持机制，作用在服务端；sessionStorage是客户端一个数据存储机制，以文件形式存在于浏览器中 大小：通常浏览器中大小在5M左右，不同的浏览器略微不同，在2.5MB 到 10MB 之间 操作： 存储：sessionStorage.setItem(key:string,value:string|object);// 高版本chrome浏览器支持直接存储json对象，其他浏览器会自动将对象进行toString处理 读取：sessionStorage.getItem(key:string); //chrome中如果设置的是对象，则读取出来的就是对象，其他浏览器必定是字符串 删除：sessionStorage.removeItem(key:string); 清空：sessionStorage.clear(); 检查：sessionStorage.key(key:string);//判断是否有key 键值对数量：sessionStorage.length 阻塞：storage操作是同步操作，会阻塞上下文 作用域： sessionStorage受同源策略影响，不可以跨域访问，sessionStorage受窗口影响，仅在当前窗口可以访问，即同源同窗口，窗口关闭后自动清除，刷新不会清除 生命周期： 临时存储，sessionStorage仅存在于当前窗口，窗口关闭即刻回收 localStorage localStorage于sessionStorage基本类似，可以参照sessionStorage去理解， 仅作用域、声明周期和事件存在区别 作用域： localStorage受同源策略影响，不可跨域访问，但可以跨窗口访问，这是跨窗口通信的一种常用方法的实现原理 生命周期： 永久存储，如果不手动清除，数据会永久存储，不会自动回收 事件：storage localStorage相比于sessionStorage多一个事件监听，这个事件在localStorage发生改变时会触发，这也是实现跨窗口通信的基础。此事件在同Context(不能说同窗口)中不会触发，在同一个上下文环境中执行监听和更新操作，是无法监听到事件触发的，只有在不同的上下文（包括不同窗口或者iframe）中分别进行更新个监听，才能正常触发该事件 CacheStorage IndexDB WebSql","tags":"h5 storage 跨窗口通信"},{"title":"database","url":"/c953062e/","text":"##前言web端对于数据的存储需求逐渐增多，越来越多的网站开始考虑，将大量数据储存在客户端,减少从服务器获取数据，直接从本地获取数据。cookie、localStorage、sessionStorage只能存储少量数据，对于大量数据或者一些框架代码的存储来说显得无力，同时不提供搜索功能，不能建立自定义的索引，因此客户端数据库的概念被h5引入。 Database Web Sql： Web Sql是W3C在H5规范中最早提出来的一个数据库理念及设计思想，但是由于后期规范完全按照SQLlite来定制，最后导致该标准被废弃，目前仅webkit部分浏览器进行了支持，主流的Chrome内核浏览器都进行了支持，Firefox等浏览器不支持该规范，因此使用时需要考虑兼容性,移动端webview中兼容性较好，高版本IOS中兼容被放弃，具体兼容性可以查看 定位： 关系型数据库，支持Sql 兼容性：兼容性不佳，低版本移动端中兼容性较好，高版本IOS已放弃兼容 同源策略限制：受同源策略影响，不可跨域访问 数据库大小 部分文档中注明Web Sql数据库的大小是50M，但是并不准确，不同的浏览器存在差异，有些远远不止50M，并没有一个固定的标准，虽然数据库方面有这样的限制，但是可以通过创建不同的数据库实例来解决该问题，大小限制仅对单个实例有效 API 创建数据库实例：openDatabase(name:string,version:string,description:string,size);// 可以指定数据库名称、版本号、描述、大小 事务处理：transaction(execute:(ctx)=&gt;void,onsuccess:()=&gt;void,onerror:()=&gt;void);// 第一个参数是事务内容的方法，在其内部调用executeSql去执行相关操作，第二个参数是事务执行成功的回调，第三个参数是事务执行失败的回调。当事务执行失败时会自动回滚到初始状态 执行sql：executeSql(sql:string,values:string[],onsuccess:()=&gt;void,onerror:()=&gt;void); // 第一个参数是sql语句字符串（SQLlite语法），第二个参数是sql中用到的?替换值，第三个参数是执行成功回调，第四个是执行失败回调 第三方库：html5sql.js html5sql.js对websql操作进行了友好性封装，使得前端人员在开发过程中使用更加方便 Index DB： Index DB是H5后期发展过程中诞生的一个新的客户端本地数据库，可以存储大量数据，该数据库在主流浏览器中兼容性原来越好，仅低版本存在一些问题，相关兼容性如下查看 定位：非关系型数据库，类似于NoSQL 兼容性：兼容性较好，主流浏览器都已支持，移动端兼容性较好，除非常低的版本意外全部兼容 数据库大小： 部分文章中指出Index DB大小在250M以上，不同的浏览器存在差异，甚至无大小上线。即使存在上限，也可以按照Web Sql的方式通过多个实例解决上线问题 特性： ①. 键值对存储，采用对象仓库存放数据，可以直接存储对象 ②. 异步，数据库操作都是异步操作，放置大量数据操作阻塞浏览器，这与storage不同 ③. 事务，Index DB 同样支持事务操作 ④. 同源，Index DB受同源策略影响，不可跨域访问 ⑤. 支持二进制存储，Index DB支持对象存储，对象中包括ArrayBuffer和Blob，因此可以存储二进制文件 API：所有操作都是异步的，api返回的都是request 创建（打开）数据库：indexDB.open(name:string,version:number);// 指定数据库名及版本号12345678910const request = window.indexedDB.open(\"databaseName\",1);// 打开或创建数据库request.onsuccess=function(event)&#123; const db = request.result;// db实例&#125;;request.onerror=function(event)&#123; // 创建失败回调&#125;;request.onupgradeneeded=function(event) &#123; // 当创建数据库或打开数据库，但指定版本大于实际版本时，触发数据库升级回调&#125; 创建对象仓库（表）：db.createObjectStore(tableName:string,config:{keyPath?:string;autoIncrement?:boolean});// keyPath主键可以是一级属性，也可以是下一层属性，例如foo.bar。该方法必须在onupgradeneeded事件中调用12345678// 创建表必须在open的upgradeneeded回调中执行openRequest.onsuccess=function(event) &#123; const db = openRequest.result; // 创建表时需要先判断该表是否存在 if (!db.objectStoreNames.contains('tableName')) &#123; const objectStore = db.createObjectStore('tableName', &#123; keyPath: 'id' &#125;);// 可以通过keyPath指定主键，也可以使用autoIncrement自动生成主键 &#125;&#125; 创建索引：objectStore.createIndex(indexName:string,keyPath: string | string[],config:{unique?:boolean;multiEntry?:boolean})// unique指定属性值是否包含重复的值，multiEntry如果为true，则会给keyPath数组中每一个元素创建一个索引，否则给整个数组创建一个索引12objectStore.createIndex('name', 'name', &#123; unique: false &#125;);objectStore.createIndex('email', 'email', &#123; unique: true &#125;); 事务：db.transaction(storeNames: string | string[], mode?: “readonly” | “readwrite”);// 需要指定涉及到的对象仓库（表），以及操作模式。整个事务成功需要在oncomplete中监听12345678910const transaction = db.transaction(['person'], 'readwrite');transaction.onsuccess=function(event) &#123; &#125;;transaction.onerror=function(event) &#123; &#125;;transaction.oncomplete=function(event) &#123; // 事务成功在complete中监听，onsuccess之后仍然可能会失败&#125; 新增数据：objectStore.add(object,key?:any);// 对象仓库（表）直接使用add添加数据对象，需要在事务中使用，第二个参数标识某条记录的键，不指定默认为null1234567const request = db.transaction(['person'], 'readwrite').objectStore(\"person\").add(&#123;name:\"Wang\"&#125;);request.onsuccess = function (event) &#123;// add request 成功监听 console.log('数据写入成功');&#125;;request.onerror = function (event) &#123; console.log('数据写入失败');&#125; 读取数据：objectStore.get(key:any|IDBKeyRange);// 通过主键值读取数据，对应获取多条记录的方法是getAll(key:any|IDBKeyRange,count?:number),key可以是一个具体的值，也可以是一个范围,IDBKeyRange可以通过其静态方法生成1234567const request = db.transaction(['person'], 'readonly').objectStore(\"person\").get(1);request.onsuccess = function (event) &#123;// get request 成功监听 console.log('数据读取成功'+request.result);&#125;;request.onerror = function (event) &#123; console.log('数据读取失败');&#125; 遍历数据：objectStore.openCursor();// 通过游标request来遍历数据12345678910111213const objectStore = db.transaction('person').objectStore('person');objectStore.openCursor().onsuccess = function (event) &#123; const cursor = event.target.result; if (cursor) &#123; console.log('Id: ' + cursor.key); console.log('Name: ' + cursor.value.name); console.log('Age: ' + cursor.value.age); console.log('Email: ' + cursor.value.email); cursor.continue(); &#125; else &#123; console.log('没有更多数据了！'); &#125;&#125;; 更新数据：objectStore.put(data:object);//更新数据需要使用put，add在主键存在时会抛错123456789const request = db.transaction(['person'], 'readwrite').objectStore('person') .put(&#123; id: 1, name: '李四', age: 35, email: 'lisi@example.com' &#125;);request.onsuccess = function (event) &#123; console.log('数据更新成功');&#125;;request.onerror = function (event) &#123; console.log('数据更新失败');&#125; 删除数据：objectStore.delete(keyValue:any);// 通过主键值删除数据1234567const request = db.transaction(['person'], 'readwrite') .objectStore('person') .delete(1);request.onsuccess = function (event) &#123; console.log('数据删除成功');&#125;; 使用索引进行查询：objectStore.index(indexName:string).get(keyValue:any);// 通过建立的索引去查询值为keyValue的数据12345678910111213const transaction = db.transaction(['person'], 'readonly');const store = transaction.objectStore('person');const index = store.index('name');const request = index.get('李四');request.onsuccess = function (e) &#123; var result = e.target.result; if (result) &#123; console.log(\"获取到指定的数据\"); &#125; else &#123; console.log(\"未找到指定数据\"); &#125;&#125; 第三方库：Dexie.js","tags":"h5 database websql indexdb"},{"title":"pwa","url":"/f17b0fbd/","text":"前言什么是PWA？PWA全称Progressive Web App，即渐进式WEB应用。是Google 在2016年提出的概念，2017年落地的web技术。目的就是在移动端利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验的渐进式网页应用。 Reliable - Load instantly and never show the downasaur, even in uncertain network conditions.Fast - Respond quickly to user interactions with silky smooth animations and no janky scrolling.Engaging - Feel like a natural app on the device, with an immersive user experience. 简介引用上述官方介绍，即可以做到： 可靠即时加载，即使在不确定的网络条件下也不会受到影响。当用户从主屏幕启动时，service work可以立即加载渐进式Web应用程序，完全不受网络环境的影响。service work就像一个客户端代理，它控制缓存以及如何响应资源请求逻辑，通过预缓存关键资源，可以消除对网络的依赖，确保为用户提供即时可靠的体验。 快速据统计，如果站点加载时间超过 3s，53% 的用户会放弃等待。页面展现之后，用户期望有平滑的体验，过渡动画和快速响应。 沉浸式体验感觉就像设备上的原生应用程序，具有沉浸式的用户体验。渐进式Web应用程序可以安装并在用户的主屏幕上，无需从应用程序商店下载安装。他们提供了一个沉浸式的全屏幕体验，甚至可以重新与用户接触的Web推送通知。 Web应用程序中，可以通过manifest.json控制应用程序的显示方式和启动方式，指定主屏幕图标、启动应用程序时要加载的页面、屏幕方向，甚至可以指定是否显示浏览器Chrome。根据官方的介绍，不难看出，PWA的目标直指原生app，那接下来我们就来了解下PWA到底是个怎么样的何方神圣。 核心功能PWA并不是指单一的技术，它是一种思想、一种概念，目的是对比原生App，通过一系列的技术去优化Web网站，提升其安全性、性能、流畅性、用户体验等方面指标，最后达到让用户像使用原生App的感觉。 PWA包含的核心技术如下： 1、Web App Manifest2、Service Worker3、Cache API4、Push&amp;Notification5、Background Sync6、响应式设计 PWA如何弥补与原生之间的差距 性能差距PWA 使用App Shell架构模型 12345671. 快速加载2. 尽可能使用较少的数据3. 使用本机缓存中的静态资产4. 将内容与导航分离开来5. 检索和显示特定页面的内容（HTML、JSON 等）6. 缓存动态内容 App Shell 可保证 UI 的本地化以及从 API 动态加载内容，但同时不影响网络的可链接性和可检测性。 用户下次访问您的应用时，应用会自动显示最新版本。无需在使用前下载新版本。为了保证首屏的加载，在内容请求完成之前，可以优先保证 App Shell 的渲染，做到和 Native App 一样的体验，App Shell 是 PWA 界面展现所需的最小资源。 离线使用 1Service Worker + HTTPS +Cache Api + indexedDB 等一系列web技术实现离线加载和缓存 数据更新 1Background Sync后台同步技术 推送功能 1Push &amp; Notification API 实现推送通知 独立启动入口 1Manifest 使得可以直接添加到手机的桌面上。 优势 无需安装，无需下载，只要你输入网址访问一次，然后将其添加到设备桌面就可以持续使用。 发布不需要提交到app商店审核 更新迭代版本不需要审核，不需要重新发布审核 现有的web网页都能通过改进成为PWA， 能很快的转型，上线，实现业务、获取流量 不需要开发Android和IOS两套不同的版本 劣势 游览器对技术支持还不够全面， 不是每一款游览器都能100%的支持所有PWA 需要通过第三方库才能调用底层硬件（如摄像头） PWA现在还没那么火，国内一些手机生产上在Android系统上做了手脚，似乎屏蔽了PWA, 但是相信当PWA火起来以后，这个问题就不会是问题 详细介绍 Manifest参考文档使用方式： 1&lt;link rel=\"manifest\" href=\"manifest.json\"&gt; 123456789101112131415&#123; &quot;name&quot;: &quot;一个PWA示例&quot;, // 必填 显示的插件名称 &quot;short_name&quot;: &quot;PWA Demo&quot;, // 可选 在APP launcher和新的tab页显示，如果没有设置，则使用name &quot;description&quot;: &quot;The app that helps you understand PWA&quot;, //用于描述应用 &quot;display&quot;: &quot;standalone&quot;, // 定义开发人员对Web应用程序的首选显示模式。standalone模式会有单独的 &quot;start_url&quot;: &quot;/&quot;, // 应用启动时的url &quot;theme_color&quot;: &quot;#313131&quot;, // 桌面图标的背景色 &quot;background_color&quot;: &quot;#313131&quot;, // 为web应用程序预定义的背景颜色。在启动web应用程序和加载应用程序的内容之间创建了一个平滑的过渡。 &quot;icons&quot;: [ // 桌面图标，是一个数组 &#123; &quot;src&quot;: &quot;/public/img/logo.png&quot;, &quot;sizes&quot;: &quot;144x144&quot;, &quot;type&quot;: &quot;image/png&quot; &#125;]&#125; Manifest在m站中使用较多，或者PC端，在App内置h5中一般不会使用。 service worker见文章serviceWorker Push &amp; Notification不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 Google Cloud Messaging 作为推送服务为例，第一步是注册 applicationServerKey(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（endpoint），订阅对象的属性(PushSubscription.endpoint) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通）。service worker中捕获用户点击消息： 12345678910111213141516 self.addEventListener('notificationclick', function (event) &#123; event.notification.close(); //关闭通知 event.waitUntil( // 获取所有clients self.clients.matchAll().then(function (clients) &#123; if (!clients || clients.length === 0) &#123; return; &#125; clients.forEach(function (client) &#123; // 使用postMessage进行通信 client.postMessage(action); console.log(\"post a message\"); &#125;); &#125;) );&#125;); App Shell 模型App Shell 架构是构建 PWA 应用的一种方式，它通常提供了一个最基本的 Web App 框架，包括应用的头部、底部、菜单栏等结构。顾名思义，我们可以把它理解成应用的一个「空壳」，这个「空壳」仅包含页面框架所需的最基本的 HTML 片段，CSS 和 javaScript，这样一来，用户重复打开应用时就能迅速地看到 Web App 的基本界面，只需要从网络中请求、加载必要的内容。我们使用 Service Worker 对 App Shell 做离线缓存，以便它可以在离线时正常展现，达到类似 Native App 的体验。","tags":"h5 pwa"},{"title":"ReactNative Optimize","url":"/42d065b1/","text":"受到react机制影响React 中渲染优化机制通常是基于PureComponent或者手动shouldComponentUpdate实现，但是在RN中存在一个问题，父组件render时，子组件声明周期中this.props.children和nextProps.children永远不相等，但是也没有创建新实例，很奇怪的现象，如果children用一个变量或属性引用保存，又不会出现该现象","tags":""},{"title":"adjust","url":"/4b038e1d/","text":"前言移动端开发中，设计到不同设备分辨率的UI大小适配问题，该问题不仅存在于H5中，RN中同样会出现该问题 解决方案 UI设计按照750标准进行效果图设计 RN中处理方法： 全局缩放：在RN的根节点上通过样式设置当前视图的缩放比例，对视图区域进行整体缩放，使得自适应变得更加简单12345678910111213141516171819202122232425import &#123;PixelRatio, Dimensions, StyleSheet&#125; from 'react-native';const dp2px = dp=&gt;PixelRatio.getPixelSizeForLayoutSize(dp);let designSize = &#123;width:750,height:1280&#125;; //假设设计尺寸为：750*1280let pxRatio = PixelRatio.get();let win_width = Dimensions.get(\"window\").width;let win_height = Dimensions.get(\"window\").height;let width = dp2px(win_width);let height = dp2px(win_height);let design_scale = designSize.width/width;height = height*design_scale;let scale = 1/pxRatio/design_scale;const styles = StyleSheet.create(&#123; page: &#123; width: width, height: height, transform: [ &#123;translateX: -width * .5&#125;, &#123;translateY: -height * .5&#125;, &#123;scale: scale&#125;, &#123;translateX: width * .5&#125;, &#123;translateY: height * .5&#125; ] &#125;&#125;); 将styles.page添加到RN页面根节点上，页面中完全按照设计稿给定的大小进行布局即可 存在问题：1.RN官方自定义组件或第三方原生组件的大小受到缩放影响，例如下拉刷新，此时大小会变得不正常 通过计算转换比例去实时计算：在样式文件中通过一个转换函数去将UI设计大小转换成实际大小12345678910111213import &#123;StyleSheet, Dimensions&#125; from 'react-native';let width = Dimensions.get(\"window\").width;// dp// UI 默认给图是 750const uiWidthPx = 750;const uiRatio = width / uiWidthPx;const styles = StyleSheet.create(&#123; infoHeader:&#123; position:\"absolute\", width:\"100%\", height:84 * uiRatio, flexDirection:\"row\" &#125;,&#125;); 在指定大小的属性后面通过”* uiRatio”的方式转换成实际大小 存在问题：1.所有样式需要手动使用表达式或者函数去进行转换，工作量增加， 比较繁琐2.动态获取View视图大小并进行处理的时候不需要进行转换，例如onLayout或者measure方法中获取的大小，这两者都是实际大小，直接进行计算即可 通过StyleSheet提供的全局代理转换拦截器进行处理StyleSheet类中提供了一个设置属性getter拦截器的方法setStyleAttributePreprocessor，可以通过这个方法设置全局属性拦截器进行自动转换1234567891011121314151617181920212223242526272829303132333435363738import &#123;StyleSheet, Dimensions&#125; from 'react-native';let width = Dimensions.get(\"window\").width;// dplet height = Dimensions.get(\"window\").height;// dp// UI 默认给图是 750const uiWidthPx = 750;const ratio = width / uiWidthPx;const ratioKeys = &#123; fontSize: true, paddingHorizontal: true, paddingLeft: true, paddingRight: true, padding: true, marginHorizontal: true, marginRight: true, marginLeft: true, margin: true, borderRadius: true, borderWidth: true, right: true, left: true, width:true, paddingVertical: true, paddingTop: true, paddingBottom: true, marginVertical: true, marginTop: true, marginBottom: true, height: true, minHeight: true, lineHeight: true, top: true, bottom: true,&#125;;Object.keys(ratioKeys).forEach(key =&gt; &#123; StyleSheet.setStyleAttributePreprocessor(key, (value) =&gt; &#123; return ratio * value; &#125;);&#125;); 存在问题：1.拦截器api处于尝试截断，后面如果修改，是否会废弃无法确定2.所有值都会进行比例缩放，包括现有组件中指定的样式大小，影响极大，出现很多超出预期的结果3.动态获取视图大小并计算后赋值给组件新的属性时会再次被拦截器转换，此时会出现不可控问题4.大部分属性支持字符串设置大小，这些属性可以使用自定义格式，例如px格式去进行拦截器处理，该方法可以规避上述2，3问题，但无法完美解决font-size、line-height等不支持字符串类型的属性，当然这两个属性也可以强制使用字符串，typescript下需要扩展类型 总结 上述三个方案中 方案一最简单，不需要考虑太多，并且复杂度最低，但是无法解决原生模块的大小问题； 方案二最是复杂，所有代码都需要进行手动调用转换，但是可配型强，哪些需要转换，哪些不需要完全可以定制，同时不影响原有组件； 方案三不太稳定，官方API暂时处于试用阶段，可能会被废弃，并且影响比较大，容易造成不良影响 建议使用方案二，开发中简单化往往带来更复杂的问题，复杂化有时候更能满足需求","tags":"rn adjust"},{"title":"client & server timeAsync","url":"/3ce3bf38/","text":"时间同步问题在客户端比较常见，通常很多的网站或者m站中都将时间转换成服务端时间，即实时调用接口，让服务端去进行请求队列处理，因为客户端时间不准确，而在某些同步场景下对于服务端的资源消耗会非常严重，并发级别很高，很多场景如果想要做并发优化，就无法实时记录每次事件的触发时间，因此客户端与服务端时间同步在一定程度上会非常棘手。本文介绍比较实用的同步方法，并介绍相关使用场景 同步方式： 页面初始化时，通过api接口response对象header中获取服务端时间并记录当前客户端时间，通过毫秒方式保存两个时间 在发生操作，需要获取服务端时间时，通过当前客户端时间与上面保存的客户端时间做计算，再加上上面保存的服务端时间，得出当前服务器时间 在所有接口中进行服务端时间的同步，确保时间误差不会太大 在App从后台切回前台时，调用时间同步接口进行一次时间同步，在浏览器从后台切回前台时同样进行一次同步，具体的浏览器判断方式可以查阅相关资料，有一些不是很成熟的方式可以参考 使用场景 对于时间精确度要求不是特别严格的场景，因此此方案多少会存在于服务器的误差 非实时需要上传的数据 本地日志上报、埋点等缓存本地，定时上报，而非实时上报","tags":"h5"},{"title":"mobile click 300-350ms","url":"/8e448d63/","text":"做过m站开发的小伙伴都清楚，在移动端，通过webview打开的网页中，js点击事件感觉比在PC浏览器中触发慢，这是因为移动端默认情况下点击事件会存在300-350ms延迟，很多人不清楚300ms的来源，只知道有这么一回事，本文主要介绍其来源及常用解决方案。 产生原因 在移动端浏览器中存在一个默认行为，那就是双击放大，因为移动端没有鼠标滚轮功能，因此设计成双击放大。浏览器底层在接收到用户点击事件时会等待一定的时间，判断用户是不是要进行双击放大操作，而这个时延===300-350ms;清楚这个原因后就可以通过其寻找解决方案。 解决方案: touch.js：通过移动端的touch事件封装一套全新的事件类型，例如tap，longTap等。该第三方库能够有效解决300ms延迟问题，但是此库会存在touch的点透问题（点击上层元素会触发下层元素的事件），相关点透的概念此处不作具体普及 fastclick.js：该库全面修改了js的click事件模型，在不改变使用方式的情况下实现延迟处理，该库没有点透问题，但是其移动端手势事件未封装，仅处理了click事件，并且fastclick相对于touch.js来说体积比较大，两库选择需要注意适用环境 viewport width：很多人不清楚这种解决方式，如果阅读过Google开发文档的小伙伴就会发现，其在2014年Chrome 32版就针对该问题做了处理，并提供了解决方案，其就是设置viewport 的width=device-width。目前该方式在Firefox及Safari(IOS 9.3)中完全兼容 viewport use-scale：同样的可以通过设置viewport 的禁止缩放来直接取消系统放大判断，禁止缩放有两种形式，如下： 123&lt;meta name=\"viewport\" content=\"user-scalable=no\"/&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1\"/&gt; //如果设置initial-scale=1.0，在chrome上是可以生效，但是Safari 不会 touch-action none：css属性touch-action设置为none，表示在该元素上的操作不会触发用户代理的任何默认行为，就无需进行300ms的延迟判断。但是其兼容性很不友好，很多浏览器不兼容。 通过上面的描述，应该对该问题有了清晰的认识，目前主流应用中，仅设置meta viewport即可，不需要单独引用其他的第三方库。如果兼容版本非常低，则需要考虑其是否支持viewport设置，如果不支持则需要引入第三方库，使用touch.js还是fastclick根据项目情况而定。","tags":"h5 fastclick click-delay"},{"title":"RN 真机调试","url":"/b90162ba/","text":"React-Native项目在Android真机上调试？接下来直奔主题，通过USB将手机和电脑连接，打开手机上的USB调试。不通型号的手机可能设置方式不一样，这里具体不在细说…… 确保你的设备已经成功连接。可以终端输入adb devices来查看:12345$ adb devicesList of devices attached\"Your device Name\" device 注意：为避免调试出现其他问题，此处只需有一台设备连接，如果模拟器打开需要关闭模拟器； 终端运行npm start 开启本地服务，成功后运行react-native run-android来在设备上安装并启动应用，或者VSCode等编辑器进行Debug Android 应用成果安装后不出意外的话会提示无法连接服务器，如下图： 出现此问题是因为我们未给手机设置访问开发服务地址，模拟器是直接访问电脑本地服务，真机则需要我们手动配置 设置设备访问开发服务器 (Android 5.0及以上)使用adb reverse命令 运行adb reverse tcp:8081 tcp:8081 不需要更多配置，你就可以使用Reload JS和其它的开发选项了。 (Android 5.0以下)通过Wi-Fi连接你的本地开发服务器 首先确保你的电脑和手机设备在同一个Wi-Fi环境下。 在设备上运行你的React Native应用。和打开其它App一样操作。 你应该会看到一个“红屏”错误提示。这是正常的，下面的步骤会解决这个报错。 摇晃设备，或者运行adb shell input keyevent 82，可以打开开发者菜单。 点击进入Dev Settings。 点击Debug server host for device。 输入你电脑的IP地址和端口号（电脑网络IP:8081）。查看电脑IP这里就不用多说啦。 回到开发者菜单然后选择Reload JS。 备注：理想状态下已经可以看到APP页面了，但是，如果上面步骤都已经做好，并且电脑本地服务终端已显示加载成功，但是APP的页面还未加载出来，显示白屏状态！是我们的步骤有问题？这里并不是我们的步骤有问题，此时只需要退出正在运行的APP，重新打开即可，就可以成功加载到APP页面啦！ 调试摇晃手机打开app的开发菜单，可以看到有两个选项，一个是Enable live reload另一个是Enable hot reloading。Enable live reload表示刷新时全局刷新,而hot reloading是局部刷新。这两个我们都选择允许后，我们改完代码并保存，可以实时看到修改效果，不用重新编译运行或者 reload。 在 app 设置 菜单中选择 Debug JS Remotely，同时PC端打开localhost:8081/debugger-ui 页面即可查看控制台，并且可以在debuggerWorker.js中设置断点进行调试","tags":""},{"title":"RN Long List","url":"/9b9cdea5/","text":"React Native 开发中经常遇到长列表场景，不仅包括无限加载瀑布流，还包括聊天列表等等，大量的列表元素堆积在页面中时对于Application的内存消耗非常严重，严重影响App的性能，因此一直以来对于长列表的优化在RN中经常涉及，本文主要介绍官方的一些长列表组件使用方式及优秀的第三方组件的使用 FlatList FlatList是官方基于ScrollView 优化的一个长列表组件，在一定程度上解决了长列表占用系统大量内存，造成系统卡顿的问题，但是性能比不上RecyclerListview。 使用过程中会出现FlatList onEndReached事件频繁触发的问题，此处主要记录该问题的引发原因及解决方案 父组件高度没有铺满整个屏幕，通常需要将父组件高度设置为100%，使用flex:1并不能完全起作用 items数量不足：onEndReached事件触发是根据当前滚动位置举例底部的距离计算比例与onEndReachedThreshold比较，如果在其范围内就会触发onEndReached事件，通常列表元素存在数据加载过程，如果加载的数据量不足以铺满整个整个屏幕，则更新时会立即触发onEndReached事件，因为此时的底部距离是0 滚动中频繁触发：在滚动过程中一般不会频繁触发，仅当检测到items发生变化，一般值长度时才允许触发下一次onEndReached事件，但是为了保证不被误触，通常使用一个控制flag来表示已经在加载下一页数据了，此时不需要再次加载下一页，当下一页数据更新完成后重置此flag 非用户行为触发：例如items数量不足，例如code实现scroll，这些情况一般不想其触发onEndReached事件，因此需要在一些用户交互事件中加一个flag进行相关控制，包括的事件：onScrollEndDrag、onScrollBeginDrag、onMomentumScrollEnd、onMomentumScrollBegin。end事件中flag置为false，start事件中flag置为true。 具体代码如下：jsx1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import React, &#123;RefObject&#125; from \"react\";import &#123;FlatList, FlatListProps, NativeScrollEvent, NativeSyntheticEvent&#125; from \"react-native\";interface IVoVaFlatListProps&lt;ITemT&gt; extends FlatListProps&lt;ITemT&gt; &#123; canRefresh?: boolean; flatListRef?:RefObject&lt;FlatList&lt;ITemT&gt;&gt;&#125;interface IVoVaFlatListState &#123; refreshing: boolean&#125;class VoVaFlatList&lt;ITemT&gt; extends React.PureComponent&lt;IVoVaFlatListProps&lt;ITemT&gt;, IVoVaFlatListState&gt; &#123; private canAction: boolean = false; private loadingNext: boolean = false; constructor(props: IVoVaFlatListProps&lt;ITemT&gt;) &#123; super(props); const &#123;canRefresh = true&#125; = props; this.state = &#123; refreshing: canRefresh &#125; &#125; private async onRefresh() &#123; const &#123;onRefresh&#125; = this.props; if (onRefresh) &#123; this.setState(&#123; refreshing: true &#125;); await onRefresh(); &#125; this.setState(&#123; refreshing: false &#125;) &#125; private async onEndReached(info: &#123; distanceFromEnd: number &#125;) &#123; if (!this.canAction) return; if (this.loadingNext) return; this.loadingNext = true; const &#123;onEndReached&#125; = this.props; // loading More if (onEndReached) &#123; await onEndReached(info); &#125; this.loadingNext = false; console.log(\"end\"); &#125; private onScrollEndDrag(event: NativeSyntheticEvent&lt;NativeScrollEvent&gt;) &#123; this.canAction = false; const &#123;onScrollEndDrag&#125; = this.props; onScrollEndDrag &amp;&amp; onScrollEndDrag(event); &#125; private onScrollBeginDrag(event: NativeSyntheticEvent&lt;NativeScrollEvent&gt;) &#123; this.canAction = true; const &#123;onScrollBeginDrag&#125; = this.props; onScrollBeginDrag &amp;&amp; onScrollBeginDrag(event); &#125; private onMomentumScrollEnd(event: NativeSyntheticEvent&lt;NativeScrollEvent&gt;) &#123; this.canAction = false; const &#123;onMomentumScrollEnd&#125; = this.props; onMomentumScrollEnd &amp;&amp; onMomentumScrollEnd(event); &#125; private onMomentumScrollBegin(event: NativeSyntheticEvent&lt;NativeScrollEvent&gt;) &#123; this.canAction = true; const &#123;onMomentumScrollBegin&#125; = this.props; onMomentumScrollBegin &amp;&amp; onMomentumScrollBegin(event); &#125; componentDidMount(): void &#123; this.onRefresh(); &#125; render() &#123; const &#123;flatListRef,refreshing,onRefresh,onEndReached,onScrollEndDrag,onMomentumScrollEnd,onScrollBeginDrag,onMomentumScrollBegin,...props&#125; = this.props; return ( &lt;FlatList ref=&#123;flatListRef&#125; &#123;...props&#125; refreshing=&#123;this.state.refreshing&#125; onRefresh=&#123;this.onRefresh.bind(this)&#125; onEndReached=&#123;this.onEndReached.bind(this)&#125; onScrollEndDrag=&#123;this.onScrollEndDrag.bind(this)&#125; onMomentumScrollEnd=&#123;this.onMomentumScrollEnd.bind(this)&#125; onScrollBeginDrag=&#123;this.onScrollBeginDrag.bind(this)&#125; onMomentumScrollBegin=&#123;this.onMomentumScrollBegin.bind(this)&#125;/&gt; ) &#125;&#125;export &#123;VoVaFlatList&#125;","tags":""},{"title":"H5 Optimize","url":"/752103c2/","text":"本文整理并归纳前端优化方案，包括移动端、PC站、前端框架、部署、架构、开发等方面优化。 需求 前端H5普及化带来的问题就是用户体验的提升及性能的优化，因此各方面的相关优化非常重要，本文主要总结前端涉及到的相关优化方式。 移动端 移动端外部资源引入需要尤其注意，如果是比较少的样式或者js可以使用内联的形式嵌入在html文件中，减少请求带来的阻塞等待时间，如果是大量或者针对第三方的文件进行缓存的可以使用外链形式，具体情况具体考虑 大图片使用wbp，图标使用svgPC站 与移动端不同的是，PC端需要尽可能的实现三层分离，让页面显得层级清晰，并且PC端网络状况比移动端好很多，受到的影响非常小 框架部署架构开发","tags":""},{"title":"h5 RTL","url":"/5213db69/","text":"本文分享关于前端中实现正反排排版的技术方案，介绍相关应用场景及成熟方案 前言 前端国际化产品中不仅涉及到多语言的解决方案，还会涉及到正反排版的问题，多语言通常对应的框架都有i18n的技术方案，而正反布局很少有比较好的解决方案，因此正反排版问题是前端工程师一直以来比较头疼的问题。 前期调研 web 开发中rtl涉及到文字及布局，而在html中有html元素的dir属性及css中direction属性去控制文本的左右排版问题，direction属性只隐性存在css中，无法控制布局显示，因此使用html标签元素的dir属性来控制左排还是右排。同时通过该属性控制不同的样式显示 一般方案 css css 中直接编写通用样式类及对应的ltr和rtl类，例如 12345678910 .test&#123; background-color:red; color: blue; &#125; [dir=ltr] .test&#123; padding-left: 10px;&#125;[dir=rtl] .test&#123; padding-right: 10px;&#125; 功能可以正常实现，但是增加了大量的开发难度，源码比较复杂，项目变得臃肿 不可通用，引用的第三方库需要重新定义一份ltr和rtl样式 less 通过less中的mixin + when + when not 通过函数的方式去判断属性是否需要进行ltr和rtl区分，如果需要则针对该属性生成单独的ltr和rtl样式类 该方法主要复杂度在mixin的实现上，mixin中需要判断所有位置相关的属性，并且需要支持css复合属性，根据不同规则去拆解计算，实现复杂度较大 该方法最终生成的css类过多，一个初始样式类中所有匹配的属性各生成两个样式类，如果不适用clean插件最终生成的样式文件臃肿，降低cssom渲染效率 不可通用，外部引入的三方库中样式基本是css,无法支持 sass 通过sass中的@mixin + @include + @if +@else去实现类似less中的判断。 负责度也等同于less方案 最终生成的样式也和less一样臃肿 不可通用，外部引入的三方库中样式基本是css,无法支持 优化解决方案 以上方案都是建立在原生css及预编译的基础上的，存在很多局限性，复杂度也比较高，通用性低 前端开发规范性要求source code保持简洁性，这种转换和目前大量使用的px2rem一样，既然px2rem存在大量的工程化插件支持自动转换，那么rtl也能同样实现 样式文件使用的工程化插件一般分为less-loader插件、sass-loader插件和postcss插件，为了通用性，我们开发postcss插件，支持所有预编译方案 模块依赖：rtlcss(目前非常成熟的主流rtl转换模块，支持所有css复合属性及background-position等，支持ltr、rtl相同属性不同值设置，支持属性忽略设置，支持样式忽略设置，支持rtl动态新增属性设置等），具体相关语法可参考官网 postcss 插件开发 熟悉postcss原理及AST语法树 插件代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const postcss = require('postcss');const postcssPluginRtl = require('rtlcss'); module.exports = postcss.plugin('postcss-plugin-rtl', opts =&gt; &#123; const &#123;exclude, include&#125; = opts || &#123;&#125;; return root =&gt; &#123; const file = root.source.input.file; if (exclude &amp;&amp; exclude.test(file) || include &amp;&amp; !include.test(file)) &#123; return ; &#125; let extraRulesList = []; root.walkRules(rule =&gt; &#123; if(rule.parent.type===\"atrule\")&#123; return; &#125; const css = rule.toString().replace(/;?&#125;$/,\";&#125;\"); const parseCss = postcssPluginRtl.process(css, &#123; useCalc: true, &#125;); const prevNode = postcss.parse(css); const nextNode = postcss.parse(parseCss); const selector = rule.selector; const rtlRule = postcss.rule(&#123; selector: \"[dir='rtl'] \" + selector&#125;); const ltrRule = postcss.rule(&#123; selector: \"[dir='ltr'] \" + selector&#125;); let rtlRuleHasChildren = false; let removeList = []; // 可能不止一个nodes for (let i = 0 ; i &lt; prevNode.nodes.length; i++) &#123; let cur = prevNode.nodes[i].nodes[0]; // 初始值 let _cur = nextNode.nodes[i].nodes[0]; // 游标遍历 while (cur) &#123; if (cur.type === \"decl\") &#123; while ( _cur.type !== \"decl\") &#123; _cur = _cur.next(); &#125; // compare // fix trim if (cur.prop !== _cur.prop || cur.value.trim() !== _cur.value.trim()) &#123; ltrRule.append(&#123; prop: cur.prop, value: cur.value, &#125;); rtlRule.append(&#123; prop: _cur.prop, value: _cur.value, &#125;); removeList.push(cur); rtlRuleHasChildren=true; &#125; _cur = _cur.next(); &#125; cur = cur.next(); &#125; &#125; removeList.map((decl) =&gt; decl.remove()); if (rtlRuleHasChildren) &#123; extraRulesList.push(rtlRule); extraRulesList.push(ltrRule); &#125; // 转成Node后进行比较 rule.replaceWith(prevNode); &#125;); root.append(extraRulesList); &#125;;&#125;); 最终生成的样式做了优化，针对每一个父样式类，仅会生成一个对应的ltr和rtl样式，其内所有属性均生成在一个类中,如下所示 使用方式，在webpack的postcss plugin中添加 最终业务样式完全按照原有设计图开发即可，如有定制按照rtlcss提供的directives去配置 hacks: AtRule：如@keyframes，@keyframes动画不支持父子选择器模式，该插件对于AtRule不作处理，因此@keyframes如果想要实现ltr与rtl不同则需要定义两个不同的动画，然后通过rtlcss directives语法指定rtl专有属性值 sass：压缩模式下行注释必须使用/*!xxx*/格式，非压缩模式下可以使用/**/。压缩模式会将最后一个属性的结束符“;”自动删除，会影响directives 解析，因此插件内部做了自动补全 less：directives完全按照官网方式配置 next： 可能存在部分未适配的case，后续遇到后做相应处理发布 &amp; 版本","tags":"h5 rtl"},{"title":"Application Cache优化","url":"/59f37da9/","text":"","tags":""},{"title":"H5","url":"/2fca13d1/","text":"不同分辨率图片","tags":""},{"title":"ReactNative环境搭建","url":"/5bef46cc/","text":"Text 换行异常问题：检查文案中空格是否正确，是否是空白字符，&#160; 该字符表示空格可以避免换行 react-native 支持svg两种方式https://www.npmjs.com/package/react-native-svg","tags":""},{"title":"About me","url":"/about/me.html","text":"","tags":""},{"title":"tags","url":"/tags/index.html","text":"","tags":""},{"title":"categories","url":"/categories/index.html","text":"","tags":""}]}