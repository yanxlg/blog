<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yanxlg@blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yanxlg.github.io/"/>
  <updated>2020-03-17T01:52:06.915Z</updated>
  <id>https://yanxlg.github.io/</id>
  
  <author>
    <name>yanxlg</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git</title>
    <link href="https://yanxlg.github.io/518e617c/"/>
    <id>https://yanxlg.github.io/518e617c/</id>
    <published>2020-03-17T01:48:45.000Z</published>
    <updated>2020-03-17T01:52:06.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h2><p>在开发过程中，我们最常用的团队协同工具就是git，因此git常用操作必须要熟练掌握</p><ol><li>多个git仓库推送：在公司开发或者个人开发一个模块，如果需要同步到个人或者公司的git仓库，这时候就显得尤其重要<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url --add origin git@gitee.com:teamemory/myH5.git   //给origin添加一个远程push地址，这样一次push就能同时push到两个地址上面</span><br><span class="line">git remote -v //查看是否多了一条push地址（这个可不执行）</span><br><span class="line">git push origin master -f // 推送到仓库</span><br><span class="line"></span><br><span class="line">git remote set-url --delete origin git@gitee.com:teamemory/myH5.git   // 删除方法</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引导&quot;&gt;&lt;a href=&quot;#引导&quot; class=&quot;headerlink&quot; title=&quot;引导&quot;&gt;&lt;/a&gt;引导&lt;/h2&gt;&lt;p&gt;在开发过程中，我们最常用的团队协同工具就是git，因此git常用操作必须要熟练掌握&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多个git仓库推送：在公司开发
      
    
    </summary>
    
    
    
      <category term="git" scheme="https://yanxlg.github.io/tags/git/"/>
    
      <category term="tools" scheme="https://yanxlg.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>rn-base</title>
    <link href="https://yanxlg.github.io/140ab620/"/>
    <id>https://yanxlg.github.io/140ab620/</id>
    <published>2020-02-27T02:05:22.000Z</published>
    <updated>2020-03-13T02:24:47.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大型RN项目中离不开拆包优化，通常拆包将bundle拆分成base和module包，base包中主要是将通用的第三方库及通用组件编译成一个独立的包供RN Context初始化时做全局加载，在页面加载时只需要加载并执行对应的module包即可。</p><h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><ul><li>npm</li><li>git</li></ul><h2 id="vv-rn-base包开发方式"><a href="#vv-rn-base包开发方式" class="headerlink" title="vv-rn base包开发方式"></a>vv-rn base包开发方式</h2><ol><li><p>clone 项目到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://g.gitvv.com/frontend/vv-rn.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">git clone ssh://git@git.gitvv.com:38022/frontend/vv-rn.git</span><br></pre></td></tr></table></figure><p>如无项目权限，请联系相关负责人授予项目权限</p></li><li><p>前端项目初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http://npm.gitvv.com/  # 设置镜像源</span><br><span class="line">npm login                                     # 登录</span><br><span class="line">npm install                                   # 安装依赖</span><br></pre></td></tr></table></figure></li><li><p>修改相关代码<br>代码可以直接修改，不需要修改配置即可发布生效</p></li><li><p>添加组件及工具类等公共文件</p></li></ol><ul><li>组件在<code>components</code>目录中添加，并需要在<code>components/index.ts</code>中<code>export</code>导出</li><li>工具类同样，在<code>utils</code>中添加，并需要在<code>utils/index.ts</code>中<code>export</code>导出</li><li>其他目录可自行添加，只要确保在<code>src/index.tsx</code>中<code>export</code>列表里包含添加的内容即可</li></ul><ol start="5"><li>添加外部依赖模块</li></ol><ul><li>package.json 中添加需要的模块并使用<code>npm install</code>或<code>yarn install</code> 安装，package.json详解见文章<a href="/14f889f2/" title="package.json">package.json</a></li><li>在<code>src/index.tsx</code>中<code>import</code>引入需要打到base 中的模块</li></ul><ol start="6"><li>如何将node_modules中模块打进module包</li></ol><ul><li>在<code>业务项目</code>根目录创建<code>bundle.json</code>文件，具体格式如下<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"^__prelude__$"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"/node_modules/"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>false：表示不编译进<code>module</code>包<br>true：表示编译进<code>module</code>包<br>注意：编译进<code>modules</code>包中的模块需要确定<code>base</code>包中不存在</p></blockquote></li></ul><ol start="7"><li>编译配置</li></ol><ul><li><p><code>/build/metro.base.config.js</code><br>业务项目编译<code>base</code>包的通用配置，一般不需要进行修改或者外部重新定义，因为里面集成了svg模块代码，需要了解相关配置才可外部重新定义</p></li><li><p><code>/build/metro.bundle.config.js</code><br>业务项目编译<code>module</code>包的通用配置，一般不需要进行修改或者外部重新定义，因为里面集成了svg模块代码，需要了解相关配置才可外部重新定义，并根据编译时间生成<code>module</code>名，确保不同页面使用同一个文件，会将改文件编译成两个不同的模块进行引用，防止页面冲突</p></li></ul><ol start="8"><li>发布</li></ol><ul><li>做完以上工作后，可以进行<code>vv-rn</code>的发布，发布前首先需要修改<code>package.json</code>中的<code>version</code>版本号，否则会发布失败</li><li>修改完版本号后，使用下面命令进行发布<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run pub</span><br></pre></td></tr></table></figure>pub命令对应文件在<code>/publish.js</code>中，如需了解，可以阅读。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;大型RN项目中离不开拆包优化，通常拆包将bundle拆分成base和module包，base包中主要是将通用的第三方库及通用组件编译成一个独
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://yanxlg.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://yanxlg.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>node/index</title>
    <link href="https://yanxlg.github.io/92faf83c/"/>
    <id>https://yanxlg.github.io/92faf83c/</id>
    <published>2020-02-27T01:44:45.746Z</published>
    <updated>2020-02-27T01:44:45.747Z</updated>
    
    <content type="html"><![CDATA[<p><code>#!/usr/bin/env node</code>：从系统PATH中查找Node，解决不同用户Node安装问题</p><p>在开发npm包使用bin时，该行代码必须放在bin文件头部，否则，安装包后生成的.bin中可执行文件会报错</p><p>require的方法  require.resolve</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;#!/usr/bin/env node&lt;/code&gt;：从系统PATH中查找Node，解决不同用户Node安装问题&lt;/p&gt;
&lt;p&gt;在开发npm包使用bin时，该行代码必须放在bin文件头部，否则，安装包后生成的.bin中可执行文件会报错&lt;/p&gt;
&lt;p&gt;requir
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Active IDEAL</title>
    <link href="https://yanxlg.github.io/396e831/"/>
    <id>https://yanxlg.github.io/396e831/</id>
    <published>2020-01-13T01:57:44.000Z</published>
    <updated>2020-03-07T05:07:01.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JetBrains 系列软件在开发圈中越来越普及，相对来说在实用性方面是最受开发人员环境的，虽然在某种程度上被<code>VSCode</code>反超，然而<code>VSCode</code>是一款免费工具，而<code>IDEAL</code>是一款收费工具，目前仅支持教育免费，通常我们并不会去购买其激活码，因为太过昂贵，最多会在淘宝上购买第三方激活码，更多的是在放上搜索可用的激活码，但是对于最新版来说网上的激活码都已经失效，生成激活码的网站也已经关闭了生成功能，本文介绍目前可用且生成属于自己的activation code的方法。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ol><li><a href="https://zhile.io/custom/license" target="_blank" rel="noopener">code 生成</a></li><li>代理包下载：<ul><li><a href="https://pan.baidu.com/s/1FGZ9d5J5amnvf0vMFqSOsQ" target="_blank" rel="noopener">百度网盘下载</a> 提取码：<code>mmk6</code></li><li><a href="https://onedrive.live.com/?authkey=%21AMIXXkzI4CJfIm8&cid=1CAC1C9786CFFED7&id=1CAC1C9786CFFED7%21892&parId=1CAC1C9786CFFED7%21891&action=locate" target="_blank" rel="noopener">OneDrive</a></li></ul></li><li>下载成功后启动需要激活的软件，选择<code>试用</code>进入软件主界面。</li><li>点击Help-&gt;Edit Custom VM Options，编辑软件配置文件，添加<code>-javaagent:E:\webStorm\jetbrains-agent.jar</code>,具体地址为你解压文件地址。</li><li>点击Help-&gt;Register输入第一步中生成的activation code激活即可</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>详细使用步骤可以参考下载包中pdf文档</p><blockquote><blockquote><blockquote></blockquote><p>本文作者： Neo Peng<br> 本文链接： <a href="https://zhile.io/2018/08/25/jetbrains-license-server-crack.html" target="_blank" rel="noopener">https://zhile.io/2018/08/25/jetbrains-license-server-crack.html</a><br> 版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！</p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;JetBrains 系列软件在开发圈中越来越普及，相对来说在实用性方面是最受开发人员环境的，虽然在某种程度上被&lt;code&gt;VSCode&lt;/c
      
    
    </summary>
    
    
    
      <category term="tools" scheme="https://yanxlg.github.io/tags/tools/"/>
    
      <category term="IDEAL" scheme="https://yanxlg.github.io/tags/IDEAL/"/>
    
      <category term="Activation" scheme="https://yanxlg.github.io/tags/Activation/"/>
    
  </entry>
  
  <entry>
    <title>Fetch</title>
    <link href="https://yanxlg.github.io/43284c47/"/>
    <id>https://yanxlg.github.io/43284c47/</id>
    <published>2019-12-06T07:01:13.000Z</published>
    <updated>2020-02-27T01:44:45.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端开发中经常涉及到接口请求，而在h5中常用的接口请求框架有<code>fetch</code>、<code>axios</code>、<code>umi-request</code>，<code>fetch</code>功能比较简单，能够满足正常的api调用需要，<code>axios</code>和<code>umi-request</code>功能比较丰富，支持取消及拦截器操作。本文主要介绍<code>fetch</code>的功能扩展。</p><h2 id="fetch-请求取消"><a href="#fetch-请求取消" class="headerlink" title="fetch 请求取消"></a>fetch 请求取消</h2><p>早期，fetch没有提供cancel操作是受到Promise的影响，计划中Promise是会提供cancel方法，fetch是打算使用Promise的cancel逻辑，但是Promise一直没有提供，因此造成fetch在使用方面不如<code>axios</code>和<code>umi-request</code>，但最近，fetch支持了cancel功能。其依赖于AbortController，低版本浏览器不支持AbortController的需要使用polyfill。<br>具体demo如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Ajax = (input: RequestInfo, init?: IIRequestInit):IFetchPromise&lt;<span class="built_in">any</span>&gt;=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;timeout,signal&#125; = init||&#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> _fetch:IFetchPromise&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">    <span class="keyword">const</span> controller = <span class="keyword">new</span> AbortController();</span><br><span class="line">    <span class="keyword">const</span> _signal = controller.signal;</span><br><span class="line">    <span class="keyword">const</span> __fetch = fetch(input,&#123;...init,signal:_signal&#125;).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response.json()</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">json=&#123;&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;code,msg&#125; = json;</span><br><span class="line">        <span class="keyword">if</span>(code===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> json;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> json;</span><br><span class="line">    &#125;);</span><br><span class="line">    signal?.addEventListener(<span class="string">'abort'</span>, <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        controller.abort();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(timeout === <span class="built_in">void</span> <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// @ts-ignore</span></span><br><span class="line">        _fetch=__fetch</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// @ts-ignore</span></span><br><span class="line">        _fetch =<span class="built_in">Promise</span>.race([</span><br><span class="line">            __fetch,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">_, reject</span>) </span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Network request failed,timeout of <span class="subst">$&#123;timeout&#125;</span> ms exceeded.`</span>));</span><br><span class="line">                    controller.abort();</span><br><span class="line">                &#125;, timeout);</span><br><span class="line">            &#125;)</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line">    _fetch.cancel=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        controller.abort();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> _fetch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="fetch-超时"><a href="#fetch-超时" class="headerlink" title="fetch 超时"></a>fetch 超时</h2><p>fetch超时一直以来也没有提供参数设置，可以参照取消请求的方式实现超时功能，当超时时取消请求并抛出超时异常</p><h2 id="RN中优化"><a href="#RN中优化" class="headerlink" title="RN中优化"></a>RN中优化</h2><p>RN中需要给每个Page组件提供一个<code>fetch</code>实例，当页面卸载时，调用该实例的<code>cancel</code>回收所有未完成的请求任务，释放资源</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前端开发中经常涉及到接口请求，而在h5中常用的接口请求框架有&lt;code&gt;fetch&lt;/code&gt;、&lt;code&gt;axios&lt;/code&gt;、&lt;c
      
    
    </summary>
    
    
      <category term="h5" scheme="https://yanxlg.github.io/categories/h5/"/>
    
    
      <category term="h5" scheme="https://yanxlg.github.io/tags/h5/"/>
    
      <category term="ajax" scheme="https://yanxlg.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>svg</title>
    <link href="https://yanxlg.github.io/3452590/"/>
    <id>https://yanxlg.github.io/3452590/</id>
    <published>2019-11-26T03:30:31.000Z</published>
    <updated>2020-02-27T01:44:45.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>react-native</code>中图片适配一直来说是个比较麻烦的问题，需要使用不同分辨率的图片，相对来说比较麻烦，对比与web端矢量图的应用，react-native中对于适量图svg的需求也越来越广泛。</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p><code>react-native</code>有一个svg的插件<code>react-native-svg</code>，该插件可以使用本地svg，但是旧版本在android生成release包时图片会不显示，因此svg的使用不尽人意，网上提供的方式是将svg通过脚本生成一个js文件存放svg中的xml，在配合<code>SvgXml</code>组件使用，该方法可行，但是每次添加图片时都需要执行脚本。</p><h2 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h2><p><code>react-native-svg</code> 新版本发布后，支持配合<code>metro</code>或者<code>babel</code>直接使用svg图片的方案，其最终编译时也是将svg图片转换成xml字符串。<a href="https://www.npmjs.com/package/react-native-svg" target="_blank" rel="noopener">具体参考插件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;react-native&lt;/code&gt;中图片适配一直来说是个比较麻烦的问题，需要使用不同分辨率的图片，相对来说比较麻烦，对比与w
      
    
    </summary>
    
    
    
      <category term="react-native" scheme="https://yanxlg.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>Call setState when unMounted</title>
    <link href="https://yanxlg.github.io/9bcaf31a/"/>
    <id>https://yanxlg.github.io/9bcaf31a/</id>
    <published>2019-11-20T05:20:41.000Z</published>
    <updated>2020-02-27T01:44:45.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>React开发过程中经常涉及到异步修改状态的问题，然而开发过程中会发现，某些操作会导致控制台提示<code>当前组件已经卸载，不应该继续调用setState修改其状态</code>，本文关于该问题点进行讨论。</p><h2 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h2><p><a href="https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html" target="_blank" rel="noopener">官方讨论</a></p><ol><li><p>React中每个组件提供了<code>isMounted()</code>方法去判断该组件是否被渲染，因此第一种方案可以为</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isMounted()) &#123; <span class="comment">// This is bad.</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;...&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种写法会使项目代码变得非常冗余且违背了警告的目的，官方也不建议使用</p></li><li><p><code>_isMounted</code>变量控制<br>在<code>componentDidMount</code>中将<code>isMounted</code>设为<code>true</code>，在<code>componentWillUnmount</code>中将其设置为<code>false</code>，调用<code>setState</code>时通过该变量进行判断，自己跟踪装载状态是为了兼容后续react升级，即使<code>isMounted</code>不可用也不会受到影响</p></li><li><p>将Api调用封装成可以<code>cancel</code>的对象<br>在<code>componentWillUnmount</code>中将接口调用cancel掉，但是官方的cancel只是简单的cancel，并不能直接cancel接口调用，仍然会消耗流量</p></li></ol><h2 id="方法推荐"><a href="#方法推荐" class="headerlink" title="方法推荐"></a>方法推荐</h2><ol><li><p>重写<code>Component</code>基类，改写<code>setState</code>方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅供简单参考，具体使用根据个人框架理解去封装</span></span><br><span class="line"><span class="keyword">class</span> BaseComponent <span class="keyword">extends</span> React.Component&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">const</span> setState = <span class="keyword">this</span>.setState;</span><br><span class="line">        <span class="keyword">this</span>.setState=<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isMounted())&#123;</span><br><span class="line">                setState(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重写<code>Component</code>基类，重置<code>setState</code>方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅供简单参考，具体使用根据个人框架理解去封装</span></span><br><span class="line"><span class="keyword">class</span> BaseComponent <span class="keyword">extends</span> React.Component&#123;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState=<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Cancel接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅供简单参考，具体使用根据个人框架理解去封装</span></span><br><span class="line"><span class="keyword">class</span> BaseComponent <span class="keyword">extends</span> React.Component&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.fetch=<span class="keyword">new</span> Fetch();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// this.fetch.post()</span></span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        <span class="keyword">this</span>.fetch.cancel();<span class="comment">// cancel掉当前所有请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;React开发过程中经常涉及到异步修改状态的问题，然而开发过程中会发现，某些操作会导致控制台提示&lt;code&gt;当前组件已经卸载，不应该继续调用
      
    
    </summary>
    
    
      <category term="-react" scheme="https://yanxlg.github.io/categories/react/"/>
    
    
      <category term="-react" scheme="https://yanxlg.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>optional-chaining</title>
    <link href="https://yanxlg.github.io/c97a3f02/"/>
    <id>https://yanxlg.github.io/c97a3f02/</id>
    <published>2019-11-18T09:45:51.000Z</published>
    <updated>2020-02-27T01:44:45.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
      
    
    </summary>
    
    
    
      <category term="typescript" scheme="https://yanxlg.github.io/tags/typescript/"/>
    
      <category term="babel" scheme="https://yanxlg.github.io/tags/babel/"/>
    
      <category term="optional-chaining" scheme="https://yanxlg.github.io/tags/optional-chaining/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="https://yanxlg.github.io/b9f20a20/"/>
    <id>https://yanxlg.github.io/b9f20a20/</id>
    <published>2019-11-18T01:09:05.000Z</published>
    <updated>2020-02-27T01:44:45.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端开发中工程化越来越重要，而工程化工具中<code>webpack</code>的地位尤其重要，本文主要介绍<code>webpack@4+</code>的相关配置。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p><code>mode</code>:”production” | “development” | “none”<br>设置webpack运行模式，不同的模式对应不同的默认配置值，例如<code>optimization</code>配置在<code>production</code>和<code>development</code>模式下默认值就有较大差别。同时模式的配置会使得webpack在编译时设置<code>process.env.NODE_ENV</code>的值，它不是Node中的环境变量，仅是webpack.DefinePlugin中定义的全局变量，因此在node进程中是无法获取到该值的，它仅对编译过程有效。</p></li><li><p><code>entry</code>:string | object | array<br>配置webpack入口文件，支持单页面和多页面方式制定入口文件，单页面使用<code>string</code>和<code>array</code>方式，多页面使用<code>object</code>方式。</p></li></ol><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol><li>UglifyJsPlugin<ul><li>compress：转换<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> CompressOptions &#123;</span><br><span class="line">    <span class="comment">/** Replace `arguments[index]` with function parameter name whenever possible. */</span></span><br><span class="line">    <span class="built_in">arguments</span>?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Various optimizations for boolean context, for example `!!a ? b : c → a ? b : c` */</span></span><br><span class="line">    booleans?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Collapse single-use non-constant variables, side effects permitting. */</span></span><br><span class="line">    collapse_vars?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Apply certain optimizations to binary nodes, e.g. `!(a &lt;= b) → a &gt; b,` attempts to negate binary nodes, e.g. `a = !b &amp;&amp; !c &amp;&amp; !d &amp;&amp; !e → a=!(b||c||d||e)` etc */</span></span><br><span class="line">    comparisons?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Apply optimizations for `if-s` and conditional expressions. */</span></span><br><span class="line">    conditionals?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Remove unreachable code */</span></span><br><span class="line">    dead_code?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pass `true` to discard calls to console.* functions.</span></span><br><span class="line"><span class="comment">     * If you wish to drop a specific function call such as `console.info` and/or retain side effects from function</span></span><br><span class="line"><span class="comment">     * arguments after dropping the function call then use `pure_funcs` instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    drop_console?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Remove `debugger;` statements */</span></span><br><span class="line">    drop_debugger?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Attempt to evaluate constant expressions */</span></span><br><span class="line">    evaluate?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Pass `true` to preserve completion values from terminal statements without `return`, e.g. in bookmarklets. */</span></span><br><span class="line">    expression?: <span class="built_in">boolean</span>;</span><br><span class="line">    global_defs?: object;</span><br><span class="line">    <span class="comment">/** hoist function declarations */</span></span><br><span class="line">    hoist_funs?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hoist properties from constant object and array literals into regular variables subject to a set of constraints.</span></span><br><span class="line"><span class="comment">     * For example: `var o=&#123;p:1, q:2&#125;; f(o.p, o.q);` is converted to `f(1, 2);`. Note: `hoist_props` works best with mangle enabled,</span></span><br><span class="line"><span class="comment">     * the compress option passes set to 2 or higher, and the compress option toplevel enabled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    hoist_props?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Hoist var declarations (this is `false` by default because it seems to increase the size of the output in general) */</span></span><br><span class="line">    hoist_vars?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Optimizations for if/return and if/continue */</span></span><br><span class="line">    if_return?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inline calls to function with simple/return statement</span></span><br><span class="line"><span class="comment">     * - false -- same as `Disabled`</span></span><br><span class="line"><span class="comment">     * - `Disabled` -- disabled inlining</span></span><br><span class="line"><span class="comment">     * - `SimpleFunctions` -- inline simple functions</span></span><br><span class="line"><span class="comment">     * - `WithArguments` -- inline functions with arguments</span></span><br><span class="line"><span class="comment">     * - `WithArgumentsAndVariables` -- inline functions with arguments and variables</span></span><br><span class="line"><span class="comment">     * - true -- same as `WithArgumentsAndVariables`</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    inline?: <span class="built_in">boolean</span> | InlineFunctions;</span><br><span class="line">    <span class="comment">/** join consecutive `var` statements */</span></span><br><span class="line">    join_vars?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Prevents the compressor from discarding unused function arguments. You need this for code which relies on `Function.length` */</span></span><br><span class="line">    keep_fargs?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Pass true to prevent the compressor from discarding function names. Useful for code relying on `Function.prototype.name`. */</span></span><br><span class="line">    keep_fnames?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Pass true to prevent Infinity from being compressed into `1/0`, which may cause performance issues on `Chrome` */</span></span><br><span class="line">    keep_infinity?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Optimizations for `do`, `while` and `for` loops when we can statically determine the condition. */</span></span><br><span class="line">    loops?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** negate `Immediately-Called Function Expressions` where the return value is discarded, to avoid the parens that the code generator would insert. */</span></span><br><span class="line">    negate_iife?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** The maximum number of times to run compress. In some cases more than one pass leads to further compressed code. Keep in mind more passes will take more time. */</span></span><br><span class="line">    passes?: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** Rewrite property access using the dot notation, for example `foo["bar"]` to `foo.bar` */</span></span><br><span class="line">    properties?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An array of names and UglifyJS will assume that those functions do not produce side effects.</span></span><br><span class="line"><span class="comment">     * DANGER: will not check if the name is redefined in scope.</span></span><br><span class="line"><span class="comment">     * An example case here, for instance `var q = Math.floor(a/b)`.</span></span><br><span class="line"><span class="comment">     * If variable q is not used elsewhere, UglifyJS will drop it, but will still keep the `Math.floor(a/b)`,</span></span><br><span class="line"><span class="comment">     * not knowing what it does. You can pass `pure_funcs: [ 'Math.floor' ]` to let it know that this function</span></span><br><span class="line"><span class="comment">     * won't produce any side effect, in which case the whole statement would get discarded. The current</span></span><br><span class="line"><span class="comment">     * implementation adds some overhead (compression will be slower).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pure_funcs?: <span class="built_in">string</span>[];</span><br><span class="line">    pure_getters?: <span class="built_in">boolean</span> | <span class="string">'strict'</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Allows single-use functions to be inlined as function expressions when permissible allowing further optimization.</span></span><br><span class="line"><span class="comment">     * Enabled by default. Option depends on reduce_vars being enabled. Some code runs faster in the Chrome V8 engine if</span></span><br><span class="line"><span class="comment">     * this option is disabled. Does not negatively impact other major browsers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    reduce_funcs?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Improve optimization on variables assigned with and used as constant values. */</span></span><br><span class="line">    reduce_vars?: <span class="built_in">boolean</span>;</span><br><span class="line">    sequences?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Pass false to disable potentially dropping functions marked as "pure". */</span></span><br><span class="line">    side_effects?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** De-duplicate and remove unreachable `switch` branches.  */</span></span><br><span class="line">    switches?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Drop unreferenced functions ("funcs") and/or variables ("vars") in the top level scope (false by default, true to drop both unreferenced functions and variables) */</span></span><br><span class="line">    toplevel?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Prevent specific toplevel functions and variables from unused removal (can be array, comma-separated, RegExp or function. Implies toplevel) */</span></span><br><span class="line">    top_retain?: <span class="built_in">boolean</span>;</span><br><span class="line">    typeofs?: <span class="built_in">boolean</span>;</span><br><span class="line">    unsafe?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Compress expressions like a `&lt;= b` assuming none of the operands can be (coerced to) `NaN`. */</span></span><br><span class="line">    unsafe_comps?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Compress and mangle `Function(args, code)` when both args and code are string literals. */</span></span><br><span class="line">    unsafe_Function?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Optimize numerical expressions like `2 * x * 3` into `6 * x`, which may give imprecise floating point results.  */</span></span><br><span class="line">    unsafe_math?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Optimize expressions like `Array.prototype.slice.call(a)` into `[].slice.call(a)` */</span></span><br><span class="line">    unsafe_proto?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** Enable substitutions of variables with `RegExp` values the same way as if they are constants. */</span></span><br><span class="line">    unsafe_regexp?: <span class="built_in">boolean</span>;</span><br><span class="line">    unsafe_undefined?: <span class="built_in">boolean</span>;</span><br><span class="line">    unused?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** display warnings when dropping unreachable code or unused declarations etc. */</span></span><br><span class="line">    warnings?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前端开发中工程化越来越重要，而工程化工具中&lt;code&gt;webpack&lt;/code&gt;的地位尤其重要，本文主要介绍&lt;code&gt;webpack@4
      
    
    </summary>
    
    
    
      <category term="webpack@4+" scheme="https://yanxlg.github.io/tags/webpack-4/"/>
    
  </entry>
  
  <entry>
    <title>require</title>
    <link href="https://yanxlg.github.io/41266748/"/>
    <id>https://yanxlg.github.io/41266748/</id>
    <published>2019-11-16T06:14:11.000Z</published>
    <updated>2020-02-27T01:44:45.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在node开发或者前端工程化开发共，经常会需要用到<code>require</code>这个方法去加载一个文件，我们所认识的<code>require</code>似乎仅仅只有这一个功能，然而<code>nodejs</code>真的仅仅如此吗？<code>require</code>似乎并没有那么简单，只是我们了解的简单而已。</p><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><ul><li>定义<br>我们先来看下关于<code>require</code>的接口定义<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NodeRequireFunction &#123;</span><br><span class="line">    (id: <span class="built_in">string</span>): <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> NodeRequire <span class="keyword">extends</span> NodeRequireFunction &#123;</span><br><span class="line">    resolve: RequireResolve;</span><br><span class="line">    cache: <span class="built_in">any</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @deprecated</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    extensions: NodeExtensions;</span><br><span class="line">    main: NodeModule | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> RequireResolve &#123;</span><br><span class="line">    (id: <span class="built_in">string</span>, options?: &#123; paths?: <span class="built_in">string</span>[]; &#125;): <span class="built_in">string</span>;</span><br><span class="line">    paths(request: <span class="built_in">string</span>): <span class="built_in">string</span>[] | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> NodeExtensions &#123;</span><br><span class="line">    <span class="string">'.js'</span>: <span class="function">(<span class="params">m: NodeModule, filename: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line">    <span class="string">'.json'</span>: <span class="function">(<span class="params">m: NodeModule, filename: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line">    <span class="string">'.node'</span>: <span class="function">(<span class="params">m: NodeModule, filename: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line">    [ext: <span class="built_in">string</span>]: <span class="function">(<span class="params">m: NodeModule, filename: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="built_in">require</span>: NodeRequire;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> NodeModule &#123;</span><br><span class="line">    exports: <span class="built_in">any</span>;</span><br><span class="line">    <span class="built_in">require</span>: NodeRequireFunction;</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    filename: <span class="built_in">string</span>;</span><br><span class="line">    loaded: <span class="built_in">boolean</span>;</span><br><span class="line">    parent: NodeModule | <span class="literal">null</span>;</span><br><span class="line">    children: NodeModule[];</span><br><span class="line">    paths: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>从定义中看，我们会发现<code>require</code>除了可以用作方法外，还有四个额外的属性:<ul><li>extensions：require支持的ext列表</li><li>cache：require缓存，多次require同一个文件会从cache中读取，并不会重新读取，因此在某些情况下并不会重新创建实例，如果想要清除cache，需要使用delete去删除cache中的key，直接置空会失效</li><li>main：可以当做入口文件的对应模块<ul><li>filename：入口文件名</li><li><code>其他一般不会使用，用到时再进行备注</code></li></ul></li><li>resolve：返回引用的（<code>模块的入口文件</code>或者<code>文件</code>）的绝对路径，通常我们需要用到fs读取模块中的某个文件，却不清楚模块安装位置时（可能全局安装、可能在<code>/node_modules</code>中，也可能在某个模块的子<code>node_modules</code>中），可以使用该方式去获取</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在node开发或者前端工程化开发共，经常会需要用到&lt;code&gt;require&lt;/code&gt;这个方法去加载一个文件，我们所认识的&lt;code&gt;r
      
    
    </summary>
    
    
    
      <category term="node" scheme="https://yanxlg.github.io/tags/node/"/>
    
      <category term="require" scheme="https://yanxlg.github.io/tags/require/"/>
    
  </entry>
  
  <entry>
    <title>performance</title>
    <link href="https://yanxlg.github.io/82d79681/"/>
    <id>https://yanxlg.github.io/82d79681/</id>
    <published>2019-11-06T07:11:51.000Z</published>
    <updated>2020-02-27T01:44:45.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>H5 项目中经常涉及到性能优化，此时需要知道页面的性能指数，并上报统计，如何知道页面的性能指数对于很多前端开发人员来说比较迷茫，本文提供一段统一的代码，统计并打印出该页面所有耗时。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> performance = <span class="built_in">window</span>.performance;</span><br><span class="line">    <span class="keyword">if</span> (performance) &#123;</span><br><span class="line">        <span class="keyword">let</span> e = performance.getEntriesByType(<span class="string">'navigation'</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> r = <span class="number">0</span>;</span><br><span class="line">        e || (r = (e = performance.timing).navigationStart);</span><br><span class="line">        <span class="keyword">const</span> n = [&#123;</span><br><span class="line">            key: <span class="string">'Redirect'</span>,</span><br><span class="line">            desc: <span class="string">'\u7f51\u9875\u91cd\u5b9a\u5411\u7684\u8017\u65f6'</span>,</span><br><span class="line">            value: e.redirectEnd - e.redirectStart</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            key: <span class="string">'AppCache'</span>,</span><br><span class="line">            desc: <span class="string">'\u68c0\u67e5\u672c\u5730\u7f13\u5b58\u7684\u8017\u65f6'</span>,</span><br><span class="line">            value: e.domainLookupStart - e.fetchStart</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            key: <span class="string">'DNS'</span>,</span><br><span class="line">            desc: <span class="string">'DNS\u67e5\u8be2\u7684\u8017\u65f6'</span>,</span><br><span class="line">            value: e.domainLookupEnd - e.domainLookupStart</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            key: <span class="string">'TCP'</span>,</span><br><span class="line">            desc: <span class="string">'TCP\u8fde\u63a5\u7684\u8017\u65f6'</span>,</span><br><span class="line">            value: e.connectEnd - e.connectStart</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            key: <span class="string">'Waiting(TTFB)'</span>,</span><br><span class="line">            desc: <span class="string">'\u4ece\u5ba2\u6237\u7aef\u53d1\u8d77\u8bf7\u6c42\u5230\u63a5\u6536\u5230\u54cd\u5e94\u7684\u65f6\u95f4 / Time To First Byte'</span>,</span><br><span class="line">            value: e.responseStart - e.requestStart</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            key: <span class="string">'Content Download'</span>,</span><br><span class="line">            desc: <span class="string">'\u4e0b\u8f7d\u670d\u52a1\u7aef\u8fd4\u56de\u6570\u636e\u7684\u65f6\u95f4'</span>,</span><br><span class="line">            value: e.responseEnd - e.responseStart</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            key: <span class="string">'HTTP Total Time'</span>,</span><br><span class="line">            desc: <span class="string">'http\u8bf7\u6c42\u603b\u8017\u65f6'</span>,</span><br><span class="line">            value: e.responseEnd - e.requestStart</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            key: <span class="string">'DOMContentLoaded'</span>,</span><br><span class="line">            desc: <span class="string">'dom\u52a0\u8f7d\u5b8c\u6210\u7684\u65f6\u95f4'</span>,</span><br><span class="line">            value: e.domContentLoadedEventEnd - r</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            key: <span class="string">'Loaded'</span>,</span><br><span class="line">            desc: <span class="string">'\u9875\u9762load\u7684\u603b\u8017\u65f6'</span>,</span><br><span class="line">            value: e.loadEventEnd - r</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.table &amp;&amp; <span class="built_in">console</span>.table(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;H5 项目中经常涉及到性能优化，此时需要知道页面的性能指数，并上报统计，如何知道页面的性能指数对于很多前端开发人员来说比较迷茫，本文提供一段
      
    
    </summary>
    
    
    
      <category term="h5" scheme="https://yanxlg.github.io/tags/h5/"/>
    
      <category term="performance" scheme="https://yanxlg.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>umi.js</title>
    <link href="https://yanxlg.github.io/a96cfee5/"/>
    <id>https://yanxlg.github.io/a96cfee5/</id>
    <published>2019-11-06T03:51:44.000Z</published>
    <updated>2020-02-27T01:44:45.751Z</updated>
    
    <content type="html"><![CDATA[<p>definePlugins 中参数：<br>‘process.env’: { NODE_ENV: ‘“production”‘ },<br>  ‘process.env.BASE_URL’: ‘“/“‘,<br>  __IS_BROWSER: ‘false’,<br>  __UMI_BIGFISH_COMPAT: undefined,<br>  __UMI_HTML_SUFFIX: ‘false’</p><p>通过 __IS_BROWSER 可以配置ssr 对应的webpack配置，及代码中环境判断，仅在编译环境有效，</p><p>umi 和 egg-bin 命令出现部分ts或es6文件转换失败，是因为<code>umi-core/lib/registerBabel</code>中配置了babel转换属性<code>only</code>，但是在<code>umi</code>中并没有传递extra属性过去</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;definePlugins 中参数：&lt;br&gt;‘process.env’: { NODE_ENV: ‘“production”‘ },&lt;br&gt;  ‘process.env.BASE_URL’: ‘“/“‘,&lt;br&gt;  __IS_BROWSER: ‘false’,&lt;br&gt;  _
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>DOM resize listener</title>
    <link href="https://yanxlg.github.io/27302137/"/>
    <id>https://yanxlg.github.io/27302137/</id>
    <published>2019-11-04T09:52:11.000Z</published>
    <updated>2020-02-27T01:44:45.741Z</updated>
    
    <content type="html"><![CDATA[<ol><li>iframe</li><li>resizeObserver ，详见observer</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;iframe&lt;/li&gt;
&lt;li&gt;resizeObserver ，详见observer&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>图片懒加载</title>
    <link href="https://yanxlg.github.io/f0e261b6/"/>
    <id>https://yanxlg.github.io/f0e261b6/</id>
    <published>2019-11-04T08:10:35.000Z</published>
    <updated>2020-02-27T01:44:45.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着H5页面图片资源的丰富，首屏页面加载效率受到明显限制，因此优化图片加载成为一个重要的需求，而图片的优化，除了压缩、缓存外，还有一个重要的方式是<code>懒加载</code>。本文主要介绍<code>懒加载</code>的实现方案及思路。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>懒加载</code>从字面看，<code>就是我比较懒，你催我要的时候我才加载，不然我就罢工休息</code>，因此主要的做法就是一开始不显示图片，在需要的时候我才加载并显示图片。什么时候才是需要的时候呢？从UI交互上讲就是图片所在的元素容器显示在viewport上的时候。因此设计方案如下：</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><ol><li>默认情况下<code>img</code>标签不设置<code>src</code>属性，仅做占位使用。</li><li>当该<code>img</code>元素被移动到可视区域<code>viewport</code>中时设置其<code>src</code>属性为需要访问的图片地址。</li><li>图片显示后回收对该图片的监听，释放资源</li></ol><p>第一步比较简单，在js或者模板中，生成<code>img</code>时，使用<code>data-src</code>属性替代<code>src</code>属性即可，关键是第二步和第三步，如何去监听及释放。<br>从掌握的前端知识中可以发现，有两种方式可以实现上面的逻辑：</p><h2 id="方案一：Observer"><a href="#方案一：Observer" class="headerlink" title="方案一：Observer"></a>方案一：Observer</h2><p>详细了解浏览器<a href="/e4278974/" title="Observer">Observer</a>的用法，我们可以发现有一个<code>Intersection Observer</code>能够观察元素位置，同时支持取消观察的API，满足当前需求，因此可以实现为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-lazyload</span> <span class="attr">data-src</span>=<span class="string">"img-1.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-lazyload</span> <span class="attr">data-src</span>=<span class="string">"img-2.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-lazyload</span> <span class="attr">data-src</span>=<span class="string">"img-3.jpg"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- more images --&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">entries, observer</span>)=&gt;</span> &#123;</span><br><span class="line">    entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">        entry.target.src = entry.target.dataset.src;</span><br><span class="line">        observer.unobserve(entry.target);<span class="comment">// 取消观察</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> lazyLoadObserver = <span class="keyword">new</span> IntersectionObserver(callback);</span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'[data-lazyload]'</span>).forEach(<span class="function"><span class="params">img</span> =&gt;</span> &#123; lazyLoadObserver.observe(img) &#125;);</span><br></pre></td></tr></table></figure><p>到此，基本功能已经实现了，可以看到代码非常简单，配合相关的框架生成html的方式使用即可，但是经过测验会发现，图片在滚动到<code>viewport</code>中时，会存在较长时间的无图现象，对于用户感知来说，不太友好，因此需要将观察区域进行延伸，修改为如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">entries, observer</span>)=&gt;</span> &#123;</span><br><span class="line">    entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">        entry.target.src = entry.target.dataset.src;</span><br><span class="line">        observer.unobserve(entry.target);<span class="comment">// 取消观察</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> lazyLoadObserver = <span class="keyword">new</span> IntersectionObserver(callback,&#123;rootMargin:<span class="string">"-50px 0 -50px 0"</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'[data-lazyload]'</span>).forEach(<span class="function"><span class="params">img</span> =&gt;</span> &#123; lazyLoadObserver.observe(img) &#125;);</span><br></pre></td></tr></table></figure><p>添加<code>rootMargin</code>参数，将观察区域相对于<code>root</code>进行放大，滚动时，当图片元素具体可视区域上或者下50px的位置时即可触发观察回调，此时立即进行图片加载，在一定的程度上，当用户将该图片滚动到可视区域中时，可能已经加载完成；具体的偏移值需要根据图片服务情况及用户网络情况确定。<br>将上述代码用于项目中会发现，部分环境<code>IntersectionObserver</code>报错，这是由于兼容性造成，<a href="/e4278974/" title="Observer">Observer</a>中详细介绍了其兼容性并提供了<code>polyfill</code>方案，其<code>polyfill</code>和下面第二种方案类似。</p><h2 id="方案二：onscroll-getComputedStyle"><a href="#方案二：onscroll-getComputedStyle" class="headerlink" title="方案二：onscroll + getComputedStyle"></a>方案二：onscroll + getComputedStyle</h2><p>传统js中判断元素与可视区域之间的位置关系用<code>getBoundingClientRect</code>API 来实现，因此，我们可以使用<code>轮询判断</code>的方式去进行元素探测，使用<code>onscroll</code>+<code>getBoundingClientRect</code>实现该功能：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imgs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'[data-lazyload]'</span>);</span><br><span class="line"><span class="keyword">const</span> callback = <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    imgs.forEach(<span class="function">(<span class="params">img:HTMLImageElement</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!img.src)&#123;</span><br><span class="line">            <span class="keyword">const</span> position = img.getBoundingClientRect();</span><br><span class="line">            <span class="keyword">if</span>(position.bottom&gt;=<span class="number">-50</span>||position&lt;=<span class="built_in">window</span>.innerHeight+<span class="number">50</span>)&#123;</span><br><span class="line">                img.src = img.dataset.src;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>,callback);</span><br></pre></td></tr></table></figure><p>代码相当简单，但是<code>并不实用</code>，主要存在以下问题：<br>    - <code>onscroll</code>触发太过频繁，每次触发都去进行dom List的遍历，开销很大<br>    - <code>getBoundingClientRect</code>容易造成浏览器重绘<br>    - <code>onscroll</code>在IOS中并不会频繁触发，只在开始和结束触发一次</p><p>根据以上问题，需要对此进行优化：<br>    - 通过<code>throttle</code>或<code>debounce</code>优化<code>onscroll</code>的频繁触发<br>    - 当<code>onscroll</code>触发不正常时，即判断IOS环境，使用<code>requestAnimationFrame</code>无限轮询代替<code>onscroll</code><br>优化代码此处不作提现，经过上面的优化，该方案可用性才明显提升。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>image 初始不要设置src属性，即使设置为<code>&quot;&quot;</code>或者<code>undefined</code>也不要，可能会造成重复载入，不同浏览器行为不一致</li></ul><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><ul><li>通过滚动距离进行节流</li><li>滚动暂停时才开始触发探测回调</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>常见的一下lazyload插件主要采用的是方案二的方式，只是或多或少在此基础上做了进一步优化，但是其效率仍然比不上方案一，建议使用方案一，实在不兼容的情况下使用方案二。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着H5页面图片资源的丰富，首屏页面加载效率受到明显限制，因此优化图片加载成为一个重要的需求，而图片的优化，除了压缩、缓存外，还有一个重要的
      
    
    </summary>
    
    
      <category term="h5" scheme="https://yanxlg.github.io/categories/h5/"/>
    
      <category term="lib" scheme="https://yanxlg.github.io/categories/h5/lib/"/>
    
    
      <category term="h5" scheme="https://yanxlg.github.io/tags/h5/"/>
    
      <category term="lib" scheme="https://yanxlg.github.io/tags/lib/"/>
    
      <category term="lazyload" scheme="https://yanxlg.github.io/tags/lazyload/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式</title>
    <link href="https://yanxlg.github.io/4caa003b/"/>
    <id>https://yanxlg.github.io/4caa003b/</id>
    <published>2019-11-04T06:13:38.000Z</published>
    <updated>2020-02-27T01:44:45.740Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式：浏览器自带的四大观察者Intersection Observer，交叉观察者。<br>                 - Mutation Observer，变动观察者。<br>                 - Resize Observer，视图观察者。<br>                 - Performance Observer，性能观察者。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;观察者模式：浏览器自带的四大观察者Intersection Observer，交叉观察者。&lt;br&gt;                 - Mutation Observer，变动观察者。&lt;br&gt;                 - Resize Observer，视图观察者。
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>前端埋点实现</title>
    <link href="https://yanxlg.github.io/8e6ad7f6/"/>
    <id>https://yanxlg.github.io/8e6ad7f6/</id>
    <published>2019-11-04T05:41:54.000Z</published>
    <updated>2020-02-27T01:44:45.739Z</updated>
    
    <content type="html"><![CDATA[<p>兴趣埋点方案：<br>位于屏幕中间，并停留时长大于2秒，计数一次。</p><pre><code>区域悬停，触发定时器记录时间。PC端记录鼠标点击次数/悬停时间，移动端记录touch事件这里就不展开写了（我懒）。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;兴趣埋点方案：&lt;br&gt;位于屏幕中间，并停留时长大于2秒，计数一次。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;区域悬停，触发定时器记录时间。

PC端记录鼠标点击次数/悬停时间，移动端记录touch事件

这里就不展开写了（我懒）。&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>前端异常监控</title>
    <link href="https://yanxlg.github.io/ff61036/"/>
    <id>https://yanxlg.github.io/ff61036/</id>
    <published>2019-11-04T05:40:57.000Z</published>
    <updated>2020-02-27T01:44:45.742Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Observer API</title>
    <link href="https://yanxlg.github.io/e4278974/"/>
    <id>https://yanxlg.github.io/e4278974/</id>
    <published>2019-11-04T04:02:24.000Z</published>
    <updated>2020-02-27T01:44:45.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端项目中经常需要用到异常监控和埋点功能，虽然大部分情况下我们都会直接接入第三方平台，因为第三方平台相对简单、稳定，通过第三方平台提供的API便可以简单实现服务注册及上报；很少我们会自己去开发一个自己的系统，但是，了解如何去开发异常监控和埋点功能还是非常有必要的。本文不针对方案进行详细介绍，如果有兴趣，可以转到<a href="/ff61036/" title="前端异常监控">前端异常监控</a>和<a href="/8e6ad7f6/" title="前端埋点实现">前端埋点实现</a>详细了解。<br>在思考方案过程中，我们想到了<a href="/4caa003b/" title="Javascript中的设计模式">Javascript中的设计模式</a>，观察者模式中提到浏览器自带的观察者如下：</p><div class="note ">            <p>1、Intersection Observer，交叉观察者。<br>2、Mutation Observer，变动观察者。<br>3、Resize Observer，视图观察者。<br>4、Performance Observer，性能观察者。</p>          </div><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><table><thead><tr><th>&emsp;&emsp;</th><th>Intersection Observer</th><th>Mutation Observer</th><th>Resize Observer</th><th>Performance Observer</th></tr></thead><tbody><tr><td>作用</td><td>观察一个元素是否在viewport中可视</td><td>观察DOM中的变化</td><td>观察DOM元素大小的变化</td><td>检测性能度量事件</td></tr><tr><td>方法</td><td>observe()<br>disconnect()<br>takeRecords()<br>unobserve()</td><td>observe()<br>disconnect()<br>takeRecords()<br>unobserve()</td><td>observe()<br>disconnect()<br>unobserve()</td><td>observe()<br>disconnect()<br>takeRecords()</td></tr><tr><td>替代</td><td>DOM Mutation events</td><td>getBoundingRect()返回元素大小及其相对于viewport的位置<br>Scroll和Resize事件</td><td>Resize事件</td><td>Performance接口</td></tr><tr><td>场景</td><td>1.无限滚动<br>2.图片懒加载<br>3.兴趣埋点<br>4.<code>控制动画、视频执行</code>（性能优化）</td><td>1.更高性能的数据绑定和响应<br>2.实现视觉差滚动<br>3.图片预加载<br>4.富文本编辑器实现</td><td>1.更智能的响应式布局（取代@media）<br>2.响应式组件</td><td>1.更细颗粒的性能检测<br>2.分析性能对业务的影响</td></tr></tbody></table><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><h3 id="Intersection-Observer：交叉观察者"><a href="#Intersection-Observer：交叉观察者" class="headerlink" title="Intersection Observer：交叉观察者"></a>Intersection Observer：交叉观察者</h3><blockquote><p><code>IntersectionObserver</code>接口，提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(<code>viewport</code>)交叉状态的方法，祖先元素与视窗(<code>viewport</code>)被称为根(<code>root</code>)</p></blockquote><h4 id="意义："><a href="#意义：" class="headerlink" title="意义："></a>意义：</h4><p>想要实时计算Web页面元素的位置，并根据位置进行交互控制，从而实现前端性能优化，这方面的实现非常依赖于<code>DOM</code>状态的显示查询，但这些查询是<code>同步</code>的，会导致昂贵的样式计算开销（重绘和回流），且不停轮询会导致大量的性能浪费。早起针对此问题有以下几种方案：</p><ul><li>定时器轮询计算每个元素的实时可见性</li><li>基于<code>享元模式</code>实现数据绑定的高性能滚动列表，列表中呈现的是数据集的子集</li><li>通过onscroll事件实时计算元素的可见性<br>这些方案存在以下共同点：<div class="note ">            <ol><li>都是查询各个元素相对与某些元素（全局视口）的“被动查询”。</li><li>过度增长的CPU使用，牺牲CPU提升性能。</li></ol>          </div></li></ul><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><p><code>Intersection Observer API</code>通过为开发人员提供一种新方法来<code>异步</code>查询元素相对于其他元素或全局视口的位置，从而解决了上述问题:</p><ul><li>异步处理消除了昂贵的DOM和样式查询，连续轮询以及使用自定义scroll插件的需求。</li><li>使应用程序显着降低CPU，GPU和资源成本。</li></ul><h4 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h4><ol><li><p>创建观察者：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    root: <span class="built_in">document</span>.querySelector(<span class="string">'.scrollContainer'</span>),</span><br><span class="line">    rootMargin: <span class="string">'0px'</span>,</span><br><span class="line">    threshold: [<span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">1</span>] </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(handler, options)</span><br></pre></td></tr></table></figure><p>配置参数的含义：<br><code>root</code>：指定根元素即观察区域元素<br><code>rootMargin</code>：通过类似css margin的值设置观察区域相对于root大小的扩展<br><code>threshold</code>：阈值，<code>number</code>或<code>Array&lt;number&gt;</code>，指定当目标元素在root指定区域内，当可见度等于阈值时触发调度函数</p><img class="lozad" title="对比图" data-src="/e4278974/640.webp"></li><li><p>定义回调事件<br>当目标与根元素通过阈值相交时，就会触发回调函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IntersectionObserverEntry &#123;</span><br><span class="line">    readonly boundingClientRect: ClientRect | DOMRect;</span><br><span class="line">    readonly intersectionRatio: <span class="built_in">number</span>;</span><br><span class="line">    readonly intersectionRect: ClientRect | DOMRect;</span><br><span class="line">    readonly isIntersecting: <span class="built_in">boolean</span>;</span><br><span class="line">    readonly rootBounds: ClientRect | DOMRect | <span class="literal">null</span>;</span><br><span class="line">    readonly target: Element;</span><br><span class="line">    readonly time: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span> (<span class="params">entries:IntersectionObserverEntry[], observer</span>) </span>&#123; </span><br><span class="line">    entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 每个成员都是一个IntersectionObserverEntry对象。</span></span><br><span class="line">    <span class="comment">// 举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。</span></span><br><span class="line">    <span class="comment">// entry.boundingClientRect </span></span><br><span class="line">    <span class="comment">// entry.intersectionRatio </span></span><br><span class="line">    <span class="comment">// entry.intersectionRect </span></span><br><span class="line">    <span class="comment">// entry.isIntersecting </span></span><br><span class="line">    <span class="comment">// entry.rootBounds </span></span><br><span class="line">    <span class="comment">// entry.target </span></span><br><span class="line">    <span class="comment">// entry.time </span></span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>time</code>：返回交叉被触发的时间的时间戳，可见性发生变化的时间，是一个高精度时间戳，单位为毫秒<br><code>rootBounds</code>：返回包含根元素的矩形区域的信息<br><code>boundingClientRect</code>：返回包含目标元素的矩形区域的信息，边界的计算方式与 <code>getBoundingClientRect()</code> 相同<br><code>intersectionRect</code>： 返回根元素和目标元素的交叉区域的信息<br><code>intersectionRatio</code>： 返回目标元素的可见比例,也就是 intersectionRect 占 boundingClientRect 的比例值，见下图<br><code>target</code>：返回目标元素的 dom 节点对象<br><code>isIntersecting</code>：目标元素是否与根元素相交</p><img class="lozad" title="对比图" data-src="/e4278974/641.webp"></li><li><p>定义观察目标对象<br>任何目标元素都可以通过调用<code>.observer(target)</code>方法来观察。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.querySelector(<span class="string">".targetBox"</span>); </span><br><span class="line">observer.observe(target);</span><br></pre></td></tr></table></figure><p>此外，还有两个停止监听的方法方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">observer.unobserve(target);<span class="comment">// 停止对某目标的监听</span></span><br><span class="line">observer.disconnect();<span class="comment">// 终止对所有目标的监听</span></span><br></pre></td></tr></table></figure></li><li><p>示例1：图片懒加载</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placeholder.png"</span> <span class="attr">data-src</span>=<span class="string">"img-1.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placeholder.png"</span> <span class="attr">data-src</span>=<span class="string">"img-2.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placeholder.png"</span> <span class="attr">data-src</span>=<span class="string">"img-3.jpg"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- more images --&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">entries, observer</span>)=&gt;</span> &#123;</span><br><span class="line">    entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/* 替换属性 */</span></span><br><span class="line">        entry.target.src = entry.target.dataset.src;</span><br><span class="line">        observer.unobserve(entry.target);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> IntersectionObserver(callback,&#123;rootMargin: <span class="string">"0px 0px -200px 0px"</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>).forEach(<span class="function"><span class="params">img</span> =&gt;</span> &#123; observer.observe(img) &#125;);</span><br></pre></td></tr></table></figure><p>html中通过js遍历或模板方式输出一批图片元素，其src属性指定为固定的logo或者占位图，并设置其data-src属性为真实图片地址，在js中通过观察器观察，当图片进入窗口区域底部200px位置时开始替换属性加载真实图片并且回收该元素监听。当然由于API兼容性问题，真实的图片懒加载不可能只有这么多代码，如要考虑在API不兼容的情况下，通过scroll事件和节流消抖来轮询检测元素位置，具体参考<a href="/f0e261b6/" title="图片懒加载">图片懒加载</a>。</p></li><li><p>示例2：兴趣埋点<br>关于兴趣埋点，一个比较通用的方案是：</p><blockquote><p>来自：《超好用的API之IntersectionObserver》</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> boxList = [...document.querySelectorAll(<span class="string">'.box'</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries</span>) =&gt;</span>&#123;</span><br><span class="line">  entries.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// intersectionRatio === 1说明该元素完全暴露出来，符合业务需求</span></span><br><span class="line">    <span class="keyword">if</span> (item.intersectionRatio === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// TODO 埋点曝光代码</span></span><br><span class="line">      io.unobserve(item.target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  root: <span class="literal">null</span>,</span><br><span class="line">  threshold: <span class="number">1</span>, <span class="comment">// 阀值设为1，当只有比例达到1时才触发回调函数</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// observe遍历监听所有box节点</span></span><br><span class="line">boxList.forEach(<span class="function"><span class="params">box</span> =&gt;</span> io.observe(box));</span><br></pre></td></tr></table></figure><p>至于怎样评断用户是否感兴趣，方案就多种多样了，此处不作叙述，需要可以查看<a href="/8e6ad7f6/" title="埋点">埋点</a></p></li><li><p>示例3：控制动画视频执行<br>这是一个比较常见的场景，如果h5列表元素中包含动画或视频，此优化是必须的，经常在面试中也会问到此类问题，此处介绍视频的控制：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"OSRO-animation.mp4"</span> <span class="attr">controls</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>);</span><br><span class="line"><span class="keyword">let</span> isPaused = <span class="literal">false</span>; <span class="comment">/* Flag for auto-paused video */</span></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123; </span><br><span class="line">  entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(entry.intersectionRatio!=<span class="number">1</span>  &amp;&amp; !video.paused)&#123;</span><br><span class="line">      video.pause(); isPaused = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(isPaused) &#123;video.play(); isPaused=<span class="literal">false</span>&#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, &#123;threshold: <span class="number">1</span>&#125;);</span><br><span class="line">observer.observe(video);</span><br></pre></td></tr></table></figure><p>这只是简单的实现，当然页面中有多个视频组成视频列表时还需要控制什么情况下才开始播放，播放中的视频仅能有一个，否则出现混乱，影响用户体验。</p></li></ol><hr><h3 id="Mutation-Observer：变动观察者"><a href="#Mutation-Observer：变动观察者" class="headerlink" title="Mutation Observer：变动观察者"></a>Mutation Observer：变动观察者</h3><blockquote><p>接口提供了监视对DOM树所做更改的能力。它被设计为旧的MutationEvents功能的替代品，该功能是DOM3 Events规范的一部分。</p></blockquote><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>归根究底，是MutationEvents的功能不尽人意：</p><div class="note ">            <ol><li>在<code>MDN</code>中也写到了，是由于<code>DOM Event</code>承认在API上有缺陷，反对使用。</li><li>核心缺陷是：性能问题和跨浏览器支持。</li><li>为DOM添加 <code>mutation</code> 监听器极度降低进一步修改DOM文档的性能（慢1.5 - 7倍），此外, 移除监听器不会逆转的损害。</li></ol>          </div><p>MutationEvents的原理：通过绑定事件监听DOM，支持的事件大致如下，不同浏览器存在兼容性差异，不需要去记录他们</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DOMAttributeNameChanged</span><br><span class="line">DOMCharacterDataModified</span><br><span class="line">DOMElementNameChanged</span><br><span class="line">DOMNodeInserted</span><br><span class="line">DOMNodeInsertedIntoDocument</span><br><span class="line">DOMNodeRemoved</span><br><span class="line">DOMNodeRemovedFromDocument</span><br><span class="line">DOMSubtreeModified</span><br></pre></td></tr></table></figure><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>MutationEvents事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；</li><li>Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。</li><li>可以通过配置项，监听目标DOM下子元素的变更记录</li></ol><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ol><li><p>创建观察者</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br></pre></td></tr></table></figure></li><li><p>定义回调函数<br>上面代码中的回调函数，会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例，下面是一个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MutationRecord &#123;</span><br><span class="line">    readonly addedNodes: NodeList;</span><br><span class="line">    readonly attributeName: <span class="built_in">string</span> | <span class="literal">null</span>;</span><br><span class="line">    readonly attributeNamespace: <span class="built_in">string</span> | <span class="literal">null</span>;</span><br><span class="line">    readonly nextSibling: Node | <span class="literal">null</span>;</span><br><span class="line">    readonly oldValue: <span class="built_in">string</span> | <span class="literal">null</span>;</span><br><span class="line">    readonly previousSibling: Node | <span class="literal">null</span>;</span><br><span class="line">    readonly removedNodes: NodeList;</span><br><span class="line">    readonly target: Node;</span><br><span class="line">    readonly <span class="keyword">type</span>: MutationRecordType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">mutations:MutationRecord[], observer</span>) </span>&#123;</span><br><span class="line">  mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mutation);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MutationRecord</code>对象中各属性含义如下：</p><table><thead><tr><th>属性</th><th>意义</th></tr></thead><tbody><tr><td>type</td><td>观察的变动类型（<code>attribute</code>、<code>characterData</code>或者<code>childList</code>）</td></tr><tr><td>target</td><td>发生变动的<code>DOM</code>节点</td></tr><tr><td>addedNodes</td><td>新增的<code>DOM</code>节点</td></tr><tr><td>removedNodes</td><td>删除的<code>DOM</code>节点</td></tr><tr><td>previousSibling</td><td>前一个同级节点，如果没有则返回null</td></tr><tr><td>nextSibling</td><td>下一个同级节点，如果没有则返回null</td></tr><tr><td>attributeName</td><td>发生变动的属性。如果设置了<code>attributeFilter</code>，则只返回预先指定的属性</td></tr><tr><td>oldValue</td><td>变动前的值。这个属性只对<code>attribute</code>和<code>characterData</code>变动有效，如果发生<code>childList</code>变动，则返回null</td></tr></tbody></table></li><li><p>定义要观察的目标</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MutationObserverInit &#123;</span><br><span class="line">    attributeFilter?: <span class="built_in">string</span>[];</span><br><span class="line">    attributeOldValue?: <span class="built_in">boolean</span>;</span><br><span class="line">    attributes?: <span class="built_in">boolean</span>;</span><br><span class="line">    characterData?: <span class="built_in">boolean</span>;</span><br><span class="line">    characterDataOldValue?: <span class="built_in">boolean</span>;</span><br><span class="line">    childList?: <span class="built_in">boolean</span>;</span><br><span class="line">    subtree?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line">mutationObserver.observe(content, &#123;</span><br><span class="line">    attributes: <span class="literal">true</span>, <span class="comment">// Boolean - 观察目标属性的改变</span></span><br><span class="line">    characterData: <span class="literal">true</span>, <span class="comment">// Boolean - 观察目标数据的改变(改变前的数据/值)</span></span><br><span class="line">    childList: <span class="literal">true</span>, <span class="comment">// Boolean - 观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化</span></span><br><span class="line">    subtree: <span class="literal">true</span>, <span class="comment">// Boolean - 目标以及目标的后代改变都会观察</span></span><br><span class="line">    attributeOldValue: <span class="literal">true</span>, <span class="comment">// Boolean - 表示需要记录改变前的目标属性值</span></span><br><span class="line">    characterDataOldValue: <span class="literal">true</span>, <span class="comment">// Boolean - 设置了characterDataOldValue可以省略characterData设置</span></span><br><span class="line">    <span class="comment">// attributeFilter: ['src', 'class'] // Array - 观察指定属性</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>优先级如下：</p><div class="note ">            <p>1、attributeFilter/attributeOldValue &gt; attributes<br>2、characterDataOldValue &gt; characterData<br>3、attributes/characterData/childList（或更高级特定项）至少有一项为true；<br>4、特定项存在, 对应选项可以忽略或必须为true</p>          </div><p>此外，还有两个停止观察的方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutationObserver.unobserve(target);<span class="comment">// 取消观察某个元素</span></span><br><span class="line">mutationObserver.disconnect();<span class="comment">// 全部取消观察</span></span><br><span class="line">mutationObserver.takeRecords();<span class="comment">// 清除变动记录。即不再处理未处理的变动。该方法返回变动记录的数组，注意，该方法立即生效。</span></span><br></pre></td></tr></table></figure></li><li><p>例子1：监听文本变化</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.getElementById(<span class="string">'target-id'</span>);</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">records</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 输入变更记录</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 开始观察</span></span><br><span class="line">observer.observe(target, &#123;</span><br><span class="line">  characterData: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里可以有几种处理。</p><ol><li>聊天的气泡框彩蛋，检测文本中的指定字符串/表情包，触发类似微信聊天的表情落下动画。</li><li>输入框的热点话题搜索，当输入”#”号时，启动搜索框预检文本或高亮话题。</li></ol><p>有个<code>Vue</code>的小型插件就是这么实现的：</p><blockquote><p>来自：《vue-hashtag-textarea》</p></blockquote></li></ol><img class="lozad" data-src="/e4278974/642.gif"><h3 id="ResizeObserver，视图观察者"><a href="#ResizeObserver，视图观察者" class="headerlink" title="ResizeObserver，视图观察者"></a>ResizeObserver，视图观察者</h3><p><code>ResizeObserver API</code>是一个新的JavaScript API，与<code>IntersectionObserver API</code>非常相似，它们都允许我们去监听某个元素的变化。</p><h4 id="意义：-1"><a href="#意义：-1" class="headerlink" title="意义："></a>意义：</h4><ul><li>开发过程当中经常遇到的一个问题就是如何监听一个 div 的尺寸变化。</li><li>但众所周知，为了监听 div 的尺寸变化，都将侦听器附加到 window 中的 resize 事件。</li><li>但这很容易导致性能问题，因为大量的触发事件。</li><li>换句话说，使用<code>window.resize</code> 通常是浪费的，因为它告诉我们每个视窗大小的变化，而不仅仅是当一个元素的大小发生变化。</li><li>而且<code>resize</code>事件会在一秒内触发将近60次，很容易在改变窗口大小时导致性能问题，比如说，你要调整一个元素的大小，那就需要在 <code>resize</code> 的回调函数 callback() 中调用 <code>getBoundingClientRect</code> 或 <code>getComputerStyle</code>。不过你要是不小心处理所有的读和写操作，就会导致布局混乱。</li></ul><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul><li>细颗粒度的<code>DOM元素</code>观察，而不是window，当然是用<code>resize</code>也可以实现单个元素的监听，具体方案参考<a href="/27302137/" title="DOM resize listener">DOM resize listener</a></li><li>没有额外的性能开销，只会在绘制前或布局后触发调用</li></ul><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><ol><li><p>创建观察者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> ResizeObserver(callback);</span><br></pre></td></tr></table></figure></li><li><p>定义回调函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">interface</span> ResizeObserverEntry &#123;</span><br><span class="line">      readonly contentRect: DOMRectReadOnly;</span><br><span class="line">      readonly target: Element;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">entries:ResizeObserverEntry[]</span>) =&gt;</span> &#123;</span><br><span class="line">    entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义要观察的目标</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observer.observe(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure><p>此外，取消观察的api有：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">observer.unobserve(<span class="built_in">document</span>.body);<span class="comment">// 取消特定元素</span></span><br><span class="line">observer.disconnect();<span class="comment">// 全部取消</span></span><br></pre></td></tr></table></figure></li><li><p>例子1：响应式组件<br>前端响应式组件通常是使用<code>@media</code>去实现的，但是<code>@media</code>仅能监控窗口大小，不能监控元素本身大小，如果布局发生改变，<code>@media</code>的响应式会存在一些问题，完美的响应式组件是监控元素本身大小，例如<code>vue-responsive-components</code>库的实现，就是通过ResizeObserver观察元素本身大小变化从而实现响应式。</p></li></ol><h3 id="PerformanceObserver：性能观察者"><a href="#PerformanceObserver：性能观察者" class="headerlink" title="PerformanceObserver：性能观察者"></a><code>PerformanceObserver</code>：性能观察者</h3><p>这是一个浏览器和Node.js 里都存在的API，采用相同W3C的Performance Timeline规范</p><ul><li>在浏览器中，我们可以使用 window 对象取得window.performance和 window.PerformanceObserver 。</li><li>而在 Node.js 程序中需要perf_hooks 取得性能对象，如下：<code>const { PerformanceObserver, performance } = require(&#39;perf_hooks&#39;);</code></li></ul><h4 id="意义：-2"><a href="#意义：-2" class="headerlink" title="意义："></a>意义：</h4><ul><li>可以获取到当前页面中与性能相关的信息。它是 <code>High Resolution Time API</code> 的一部分，同时也融合了 <code>Performance Timeline API</code>、<code>Navigation Timing API</code>、 <code>User Timing API</code> 和 <code>Resource Timing API</code></li><li><code>Performance API</code> 是大家熟悉的一个接口，他记录着几种性能指数的庞大对象集合<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PerformanceTiming &#123;</span><br><span class="line">    readonly connectEnd: <span class="built_in">number</span>;</span><br><span class="line">    readonly connectStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly domComplete: <span class="built_in">number</span>;</span><br><span class="line">    readonly domContentLoadedEventEnd: <span class="built_in">number</span>;</span><br><span class="line">    readonly domContentLoadedEventStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly domInteractive: <span class="built_in">number</span>;</span><br><span class="line">    readonly domLoading: <span class="built_in">number</span>;</span><br><span class="line">    readonly domainLookupEnd: <span class="built_in">number</span>;</span><br><span class="line">    readonly domainLookupStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly fetchStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly loadEventEnd: <span class="built_in">number</span>;</span><br><span class="line">    readonly loadEventStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly navigationStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly redirectEnd: <span class="built_in">number</span>;</span><br><span class="line">    readonly redirectStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly requestStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly responseEnd: <span class="built_in">number</span>;</span><br><span class="line">    readonly responseStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly secureConnectionStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly unloadEventEnd: <span class="built_in">number</span>;</span><br><span class="line">    readonly unloadEventStart: <span class="built_in">number</span>;</span><br><span class="line">    toJSON(): <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Performance <span class="keyword">extends</span> EventTarget &#123;</span><br><span class="line">    <span class="comment">/** @deprecated */</span></span><br><span class="line">    readonly navigation: PerformanceNavigation;</span><br><span class="line">    onresourcetimingbufferfull: <span class="function">(<span class="params">(<span class="params"><span class="keyword">this</span>: Performance, ev: Event</span>) =&gt; <span class="built_in">any</span></span>) | <span class="params">null</span>;</span></span><br><span class="line"><span class="function">    <span class="params">readonly</span> <span class="params">timeOrigin</span>: <span class="params">number</span>;</span></span><br><span class="line"><span class="function">    /** @<span class="params">deprecated</span> */</span></span><br><span class="line"><span class="function">    <span class="params">readonly</span> <span class="params">timing</span>: <span class="params">PerformanceTiming</span>;</span></span><br><span class="line"><span class="function">    <span class="params">clearMarks</span>(<span class="params">markName?: <span class="built_in">string</span></span>): <span class="params">void</span>;</span></span><br><span class="line"><span class="function">    <span class="params">clearMeasures</span>(<span class="params">measureName?: <span class="built_in">string</span></span>): <span class="params">void</span>;</span></span><br><span class="line"><span class="function">    <span class="params">clearResourceTimings</span><span class="params">()</span>: <span class="params">void</span>;</span></span><br><span class="line"><span class="function">    <span class="params">getEntries</span><span class="params">()</span>: <span class="params">PerformanceEntryList</span>;</span></span><br><span class="line"><span class="function">    <span class="params">getEntriesByName</span>(<span class="params">name: <span class="built_in">string</span>, <span class="keyword">type</span>?: <span class="built_in">string</span></span>): <span class="params">PerformanceEntryList</span>;</span></span><br><span class="line"><span class="function">    <span class="params">getEntriesByType</span>(<span class="params"><span class="keyword">type</span>: <span class="built_in">string</span></span>): <span class="params">PerformanceEntryList</span>;</span></span><br><span class="line"><span class="function">    <span class="params">mark</span>(<span class="params">markName: <span class="built_in">string</span></span>): <span class="params">void</span>;</span></span><br><span class="line"><span class="function">    <span class="params">measure</span>(<span class="params">measureName: <span class="built_in">string</span>, startMark?: <span class="built_in">string</span>, endMark?: <span class="built_in">string</span></span>): <span class="params">void</span>;</span></span><br><span class="line"><span class="function">    <span class="params">now</span><span class="params">()</span>: <span class="params">number</span>;</span></span><br><span class="line"><span class="function">    <span class="params">setResourceTimingBufferSize</span>(<span class="params">maxSize: <span class="built_in">number</span></span>): <span class="params">void</span>;</span></span><br><span class="line"><span class="function">    <span class="params">toJSON</span><span class="params">()</span>: <span class="params">any</span>;</span></span><br><span class="line"><span class="function">    <span class="params">addEventListener</span>&lt;<span class="params">K</span> <span class="params">extends</span> <span class="params">keyof</span> <span class="params">PerformanceEventMap</span>&gt;(<span class="params"><span class="keyword">type</span>: K, listener: (<span class="params"><span class="keyword">this</span>: Performance, ev: PerformanceEventMap[K]</span>) =&gt; <span class="built_in">any</span>, options?: <span class="built_in">boolean</span> | AddEventListenerOptions</span>): <span class="params">void</span>;</span></span><br><span class="line"><span class="function">    <span class="params">addEventListener</span>(<span class="params"><span class="keyword">type</span>: <span class="built_in">string</span>, listener: EventListenerOrEventListenerObject, options?: <span class="built_in">boolean</span> | AddEventListenerOptions</span>): <span class="params">void</span>;</span></span><br><span class="line"><span class="function">    <span class="params">removeEventListener</span>&lt;<span class="params">K</span> <span class="params">extends</span> <span class="params">keyof</span> <span class="params">PerformanceEventMap</span>&gt;(<span class="params"><span class="keyword">type</span>: K, listener: (<span class="params"><span class="keyword">this</span>: Performance, ev: PerformanceEventMap[K]</span>) =&gt; <span class="built_in">any</span>, options?: <span class="built_in">boolean</span> | EventListenerOptions</span>): <span class="params">void</span>;</span></span><br><span class="line"><span class="function">    <span class="params">removeEventListener</span>(<span class="params"><span class="keyword">type</span>: <span class="built_in">string</span>, listener: EventListenerOrEventListenerObject, options?: <span class="built_in">boolean</span> | EventListenerOptions</span>): <span class="params">void</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></li><li><code>Performance API</code>若想获得某项页面加载性能记录，就需要调用performance.getEntries或者performance.getEntriesByName来获得。</li><li><code>Performance API</code>而获得执行效率，也只能通过performance.now来计算。</li></ul><h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h4><p><code>PerformanceObserver</code>是浏览器内部对<code>Performance</code>实现的观察者模式，也是现代浏览器支持的几个 Observer 之一。</p><blockquote><p>来自：《你了解 Performance Timeline Level 2 吗？》</p></blockquote><p>它解决了以下3点问题：</p><div class="note ">            <ol><li>避免不知道性能事件啥时候会发生，需要重复轮训timeline获取记录。</li><li>避免产生重复的逻辑去获取不同的性能数据指标</li><li>避免其他资源需要操作浏览器性能缓冲区时产生竞态关系。</li></ol>          </div><div class="note warning">            <p><code>W3C</code>官网文档鼓励开发人员尽可能使用<code>PerformanceObserver</code>，而不是通过<code>Performance</code>获取性能参数及指标。</p>          </div><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>创建观察者</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> PerformanceObserver(callback);</span><br></pre></td></tr></table></figure></li><li><p>定义回调函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PerformanceObserverEntryList &#123;</span><br><span class="line">    getEntries(): PerformanceEntryList;</span><br><span class="line">    getEntriesByName(name: <span class="built_in">string</span>, <span class="keyword">type</span>?: <span class="built_in">string</span>): PerformanceEntryList;</span><br><span class="line">    getEntriesByType(<span class="keyword">type</span>: <span class="built_in">string</span>): PerformanceEntryList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> PerformanceEntry &#123;</span><br><span class="line">    readonly duration: <span class="built_in">number</span>;</span><br><span class="line">    readonly entryType: <span class="built_in">string</span>;</span><br><span class="line">    readonly name: <span class="built_in">string</span>;</span><br><span class="line">    readonly startTime: <span class="built_in">number</span>;</span><br><span class="line">    toJSON(): <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">list:PerformanceObserverEntryList, observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> entries = list.getEntries();</span><br><span class="line">    entries.forEach(<span class="function">(<span class="params">entry:PerformanceEntry</span>) =&gt;</span> &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义要观察的目标对象</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PerformanceObserverInit &#123;</span><br><span class="line">    buffered?: <span class="built_in">boolean</span>;</span><br><span class="line">    entryTypes?: <span class="built_in">string</span>[];</span><br><span class="line">    <span class="keyword">type</span>?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line">observer.observe(&#123;entryTypes: [<span class="string">"entryTypes"</span>]&#125; <span class="keyword">as</span> PerformanceObserverInit);</span><br></pre></td></tr></table></figure><p><code>observer.observe(...)</code>方法接受可以观察到的有效的入口类型。这些输入类型可能属于各种性能API，比如<code>User Tming</code>或<code>Navigation Timing API</code>。有效的<code>entryType</code>值：</p><table><thead><tr><th>属性</th><th>别名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>frame<br>navigation</td><td><code>PerformanceFrameTiming</code><br><code>PerformanceNavigationTiming</code></td><td>URL</td><td>文件的地址</td></tr><tr><td>resource</td><td><code>PerformanceResourceTiming</code></td><td>URL</td><td>所请求资源的解析URL</td></tr><tr><td>mark</td><td><code>PerformanceMark</code></td><td>DOMString</td><td>通过调用创建标记时使用的名称performance.mark()</td></tr><tr><td>measure</td><td><code>PerformanceMeasure</code></td><td>DOMString</td><td>通过调用创建度量时使用的名称performance.measure()</td></tr><tr><td>paint</td><td><code>PerformancePaintTiming</code></td><td>DOMString</td><td>无论是<code>first-paint</code>或<code>first-contentful-paint</code></td></tr><tr><td>longtask</td><td><code>PerformanceLongTaskTiming</code></td><td>DOMString</td><td>报告长任务的实例</td></tr></tbody></table></li><li><p>例子：静态资源监控</p><blockquote><p>来自：《资源监控》</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterTime</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span> &amp;&amp; (a - b) &gt;= <span class="number">0</span>) ? (a - b) : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resolvePerformanceTiming = <span class="function">(<span class="params">timing</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> o = &#123;</span><br><span class="line">    initiatorType: timing.initiatorType,</span><br><span class="line">    name: timing.name,</span><br><span class="line">    duration: <span class="built_in">parseInt</span>(timing.duration),</span><br><span class="line">    redirect: filterTime(timing.redirectEnd, timing.redirectStart), <span class="comment">// 重定向</span></span><br><span class="line">    dns: filterTime(timing.domainLookupEnd, timing.domainLookupStart), <span class="comment">// DNS解析</span></span><br><span class="line">    connect: filterTime(timing.connectEnd, timing.connectStart), <span class="comment">// TCP建连</span></span><br><span class="line">    network: filterTime(timing.connectEnd, timing.startTime), <span class="comment">// 网络总耗时</span></span><br><span class="line"></span><br><span class="line">    send: filterTime(timing.responseStart, timing.requestStart), <span class="comment">// 发送开始到接受第一个返回</span></span><br><span class="line">    receive: filterTime(timing.responseEnd, timing.responseStart), <span class="comment">// 接收总时间</span></span><br><span class="line">    request: filterTime(timing.responseEnd, timing.requestStart), <span class="comment">// 总时间</span></span><br><span class="line"></span><br><span class="line">    ttfb: filterTime(timing.responseStart, timing.requestStart), <span class="comment">// 首字节时间</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resolveEntries = <span class="function">(<span class="params">entries</span>) =&gt;</span> entries.map(<span class="function"><span class="params">item</span> =&gt;</span> resolvePerformanceTiming(item));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resources = &#123;</span><br><span class="line">  init: <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> performance = <span class="built_in">window</span>.performance || <span class="built_in">window</span>.mozPerformance || <span class="built_in">window</span>.msPerformance || <span class="built_in">window</span>.webkitPerformance;</span><br><span class="line">    <span class="keyword">if</span> (!performance || !performance.getEntries) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">void</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.PerformanceObserver) &#123;</span><br><span class="line">      <span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="built_in">window</span>.PerformanceObserver(<span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> entries = list.getEntries();</span><br><span class="line">          cb(resolveEntries(entries));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      observer.observe(&#123;</span><br><span class="line">        entryTypes: [<span class="string">'resource'</span>]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> entries = performance.getEntriesByType(<span class="string">'resource'</span>);</span><br><span class="line">        cb(resolveEntries(entries));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote><ul><li>资源监控</li><li>Media Queries Based on Element Width with MutationObserver</li><li>以用户为中心的性能指标</li><li>A Few Functional Uses for Intersection Observer to Know When an Element is in View</li><li>Getting To Know The MutationObserver API</li><li>Different Types Of Observers Supported By Modern Browsers</li><li>THE RESIZE OBSERVER EXPLAINED</li><li>A Look at the Resize Observer JavaScript API </li></ul></blockquote><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><a href="https://caniuse.com/#search=Intersection%20Observer" target="_blank" rel="noopener">Intersection Observer</a> | <a href="https://caniuse.com/#search=Mutation%20Observer" target="_blank" rel="noopener">Mutation Observer</a> | <a href="https://caniuse.com/#search=Resize%20Observer" target="_blank" rel="noopener">Resize Observer</a> | <a href="https://caniuse.com/#search=Performance%20Observer" target="_blank" rel="noopener">Performance Observer</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这四个观察者，都非常适合集成到监控系统。虽然其兼容性有一定的限制，但是都有对应的polyfills：<br>Intersection Observer：intersection-observer<br>Mutation Observer：mutationobserver-shim<br>Resize Observer：resize-observer-polyfill<br>Performance Observer：@fastly/performance-observer-polyfill</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前端项目中经常需要用到异常监控和埋点功能，虽然大部分情况下我们都会直接接入第三方平台，因为第三方平台相对简单、稳定，通过第三方平台提供的AP
      
    
    </summary>
    
    
      <category term="h5" scheme="https://yanxlg.github.io/categories/h5/"/>
    
      <category term="API" scheme="https://yanxlg.github.io/categories/h5/API/"/>
    
    
  </entry>
  
  <entry>
    <title>Tree Structure</title>
    <link href="https://yanxlg.github.io/e06277db/"/>
    <id>https://yanxlg.github.io/e06277db/</id>
    <published>2019-11-04T03:25:35.000Z</published>
    <updated>2020-02-27T01:44:45.740Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="h5" scheme="https://yanxlg.github.io/categories/h5/"/>
    
      <category term="data structure" scheme="https://yanxlg.github.io/categories/h5/data-structure/"/>
    
    
      <category term="data structure" scheme="https://yanxlg.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="https://yanxlg.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Babel</title>
    <link href="https://yanxlg.github.io/7056c18d/"/>
    <id>https://yanxlg.github.io/7056c18d/</id>
    <published>2019-11-04T02:38:39.000Z</published>
    <updated>2020-02-27T01:44:45.738Z</updated>
    
    <content type="html"><![CDATA[<p><code>babel-plugin-module-resolver</code> 插件的妙用</p><p>babel 中typescript 不支持enum 等，但是rn的preset<code>metro-react-native-babel-preset</code>中却支持，可以研究</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;babel-plugin-module-resolver&lt;/code&gt; 插件的妙用&lt;/p&gt;
&lt;p&gt;babel 中typescript 不支持enum 等，但是rn的preset&lt;code&gt;metro-react-native-babel-preset&lt;/code
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
